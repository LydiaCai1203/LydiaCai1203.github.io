<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hugo Cactus Theme</title>
    <link>https://lydiacai1203.github.io/post/</link>
    <description>Recent content in Posts on Hugo Cactus Theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 13 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://lydiacai1203.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>君主论 - 论市民的君主国</title>
      <link>https://lydiacai1203.github.io/post/the_prince_five/</link>
      <pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/the_prince_five/</guid>
      <description>如果一个平民，不是依靠 罪恶之道，而是由于获得本土其它市民的赞助而成为君主，这种国家称为 市民的君主国。 每个城市里都可以找到两个互相对立的党派。因为人民不愿意被贵族 统治与压迫，贵族则要求 统治与压迫人民。由于这两种相反的愿望，城市里最终会演变成以下三种结果：君主权、自主权、无政府状态。君主政体：不是由人民建立，就是由贵族建立，主要看哪方抓住了机会。当贵族发现自己统治不了人民，就开始抬高他们当中某一个人的声望。当人民察觉自己抵抗不了贵族，也会抬高他们当中某一个人的声望，扶持他成为君主，以求保护。
一个人如果依靠贵族的帮助取得君权，会比依靠人民的帮助获得的君权更难于保持。因为君主会发现自己周围有许多人自以为同他是平等的，所以他也不能按照自己的意思随意指挥或者管理他们。一个人如果依靠人民的赞助取得君权，他会发现自己是巍然独立的人，在自己周围没有人不服从自己，有也只是极少数。除此之外，如果君主能公平地处理事情而不损害他人，虽然不能满足贵族的欲望，但却能让人民满足。人民的目的比贵族的目的来的公正，毕竟前者只是不想被压迫而已。
人民数量多于贵族，因此如果人民感怀不满，君主是永远也得不到安全的。虽然如此，但人民所能做的最坏的事情可以预料，左不过就是抛弃自己。而贵族的眼光更加敏锐深远，常常能避免于难，因此贵族对君主的抛弃和反对更加可怕。没有上述贵族，君主可以过的更好，因为他可以随时设立或者废黜贵族，并且能够随心所欲地给予或者抹掉他们的名声。
统治贵族应该：对于约束自己行为且不贪婪的贵族，应该给予光荣和爱护。对胆怯或天生缺乏勇气的贵族，应该利用他们，尤其是那些能给你提出有益意见的。如此当你隆盛的时候，他们会尊敬你；当你处于逆境的时候，也无需畏惧他们。对于属于其它情况的贵族，要让他们依靠你，没有你不行。其中故意不依靠你是一种征象，意味着他们为自己着想比替你想的跟多。君主要防范这类人，把他们当作公开的敌人那样警惕，在对君主不利的时期，总是这群人出来灭掉君主。
统治人民应该：同人民保持友好关系，只要做到不压迫人民就能达到目的。
如果君主是由于贵族的帮助取得君权，成为君主后头一件事情就是争取人民，如上所述，只需将人民置于自己的保护之下即可，人民本以为会被压迫，现在却得到好处，一定会对自己的恩人更加接近。总之君主一定要和人民保持友谊，否则在逆境之中就无补救方法。
以上论述只适用于君主，而非平民。如果一个平民把自己的基础建立在人民之上，并且深信自己收到敌人或者官吏压迫时，人民会解救自己，那么他注定失望。
最后，英民的君主应考虑的是使他的市民无论处于哪一个时期（太平时期 &amp;amp;&amp;amp; 危难时期）对于国家或事他个人，都有所需求，他们就会对你永远效忠了。
最后的最后，俺来总结： 依靠群众取得的政权比依靠贵族取得的政权来的稳固 a. 人民数量大，起义不好控制 b. 人民要求低，很容易满足和被控制 c. 获得政权以后消灭贵族 d. 无法消灭贵族就要使得贵族的利益与自己的决定牢牢相关 e. 嘉奖重用那些听话的贵族做表率 f. 不要相信和平时期的承诺 公司里顶层人员的调动往往会带动所在部门领导的流动。我遇到过那种抢夺属下 KPI 的领导，遇到过因为临危受命而来却因权利更迭被抛弃而全心全意保护下属的领导。人总是在利益不相关的情况下选择冷眼旁观，因此更要提防对你热心友好的人，背后的目的是什么。是希望得到下属拥戴巩固权力的领导，还是希望得到同事好评的即将晋升的同事。这个世界没有对错，只有立场。当别人反对你时，不代表你的观点你的成果不好，可能仅仅是因为他也有一样的观点或成果要推出，为了争抢那点 KPI 和在领导心里的地位，总是要不顾一切打击利益负相关的人。不要盲目地否认自己，当然也不要盲目自信。 </description>
    </item>
    
    <item>
      <title>君主论 - 论以邪恶之道获得君权的人们</title>
      <link>https://lydiacai1203.github.io/post/the_prince_four/</link>
      <pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/the_prince_four/</guid>
      <description>1. 希腊西西里国王 - 阿加托克雷 阿加托克雷 是一个陶工的儿子，从小就坏，后来他投身军队，经过努力成为 锡拉库萨 的地方执政官。但他的野心不仅如此，而是想当上 锡拉库萨 国王。上位是设计召集 锡拉库萨 人民和元老院，假意商讨共和国国事，实际是为了斩杀他们。他的士兵杀掉了元老院和最富有的一群人，使他成功成为锡拉库萨的国王。阿加托克雷延续了叙拉古统治者与迦太基人争夺 西西里 主导的政策，他引诱迦太基人攻打锡拉库萨，自己则带领一批兵马攻打 非洲。使得迦太基人陷入窘境，被迫同阿加托克雷讲和，迦太基人占领非洲就足够了，把西西里让给了阿加托克雷。
2. 费莫尔 - 奥里维罗托 奥里维罗托 从小由舅舅抚养，后被送至 保罗·维泰利 手下当兵，保罗死后又去了保罗弟弟 维泰洛佐 手下当兵，由于他的机智和身强胆壮，他很快成为军中第一人。但他的野心，使他不敢屈居于人。于是他写了一封信给自己的舅舅，声称想回故乡看看祖产，并且由于自己对荣誉的看重，想随行一百名骑兵同去。他请求舅舅安排一切。舅舅非常高兴且尽心地安排好一切，并接 奥里维罗托 入住自己家。随后 奥里维罗托 举办了场宴会，邀请了舅舅和一些重要人物，并设计把他们骗入房中杀害。随后 奥里维罗托 又把宫廷里的最高长官围困住，迫使他们承认他是国王。他把那些对他心怀不满可能加害于他的人全都杀了。
3. 总结 有些人奸诈残暴，却能长治久安地治理自己的国家，人民也不反抗，敌人也不敢入侵。有些人奸诈残暴却在和平时期都不能保有自己的国家。这是由于前者 妥当 地使用残暴手段。后者 恶劣 地使用残暴手段使然。
妥善： 为了自己安全的必要，可以偶然地使用残暴手段。除非残暴的手段可以为自己的臣民谋得福利，并且此后都坚决不再使用。
恶劣： 尽管开始使用残暴的手段是寥寥可数的，可是其后与时俱增。
由此可见，占领者在夺取一个国家的时候，应该审度自己必须从事的一切损害行为，并且要立即毕其功于一役，使自己日后不必日复一日地搞下去。这样一来，由于不需要一再地从事侵害行为，他能够重新使得人民感到安全，并且通过施恩布惠把他们争取过来。反之，如果一个人由于怯懦不这样做，他的手里就必须时时刻刻拿着武器，他也永远无法信赖自己的百姓，人民会由于他的不断损害感到不安全。因此 损害应该一下子干完，人民的积怨就会少一些。恩惠应该一点点给予，以便人民更好地品尝恩惠的滋味。此外，轻易不能更改关于从事损害行为和施恩布惠的政策，因为此时即使做好事也无法挽回，人们只会认为你是被迫如此。而不会对你产生任何感谢。</description>
    </item>
    
    <item>
      <title>君主论 - 论依靠他人的武力或者由于幸运而取得得新君主国</title>
      <link>https://lydiacai1203.github.io/post/the_prince_three/</link>
      <pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/the_prince_three/</guid>
      <description>如果一个人认为，为了确保他的新的王国领土安全免遭敌人的侵害，有必要争取朋友，依靠武力或者讹诈制胜，使得人民对自己又爱戴又畏惧，使用军队既服从又尊敬自己，把那些能够或者可能加害自己的人们消灭掉。采用新的方法把旧制度加以革新，既有严峻的一面使人感恩，要宽宏大量且慷慨好施，要摧毁不忠诚的军队，创建新的军队，要同各国国王和君主们保持友好，使他们不得不殷勤地帮助自己，或者是诚惶诚恐不敢得罪自己。
如果任何人相信给以新的恩惠就会使一个大人物忘却旧日的损害，他就是欺骗自己。因为人们会处于恐惧或者仇恨来损害你。这让我想起知乎上的一个回答，如何让一个心智俱全的人忘记往日受到的伤害。</description>
    </item>
    
    <item>
      <title>不能完全相信大脑</title>
      <link>https://lydiacai1203.github.io/post/thinking_1/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/thinking_1/</guid>
      <description>一直以来，我都经常会为自己的很多行为感到不解。比如，为什么那么在乎别人是否正确明白自己想表达的意思。这种固执让我不轻易在言语上认输，我为此一直感到苦恼。
早些时候我一直将此归咎于自己不幸的童年。大约是两年前，看了一本书，出于实践目的，我开始套用书上公式，将一些行为与我的童年挂钩，不幸地是，皆找到合理的解释将星星点点的事物联系在了一起。我开始把 我的固执 与 童年时期的思考经常得到父母的否定 联系在一起。现在想来，父母只是这个习惯的催化剂。
美国 大卫.萨迪沃 的《反套路》为我这种行为作出的解释是:
1. 渴望确定性 我们的大脑喜欢 正确、持续、稳定 的东西。我们需要知道 &amp;ldquo;自己是对的&amp;rdquo;。事实上，我们需要 感觉自己是对的。这就是人类的天性与后天形成的认知偏差让我们相信自己永远是对的。当我们觉得某个决策，某种信念是正确的。无论它是大小，大脑都会感到快乐，因为大脑喜欢处于快乐的状态，所以我们喜欢 &amp;ldquo;感觉自己是对的&amp;rdquo;，但 &amp;ldquo;感觉是对的&amp;rdquo; 意味这 &amp;ldquo;可能是不对的&amp;rdquo;，因此这种 &amp;ldquo;感觉是对的&amp;rdquo; 往往会被我们当成 &amp;ldquo;这就是对的&amp;rdquo;。
2. 证实性偏差 人们寻找能证明自己观点的证据，忽略不能证明自己观点的证据，这就是 证实性偏差。于 睡觉、性爱、烧烤 一样，这就是人类的天性。许多人在接触到反认知的东西时，会感到愤怒，他会急于寻找新证据，但是目的并非是理性地评估新发现的信息，说服自己改变立场，而是先寻找能证明现有立场的信息，因为他们压根就不可能改变立场。当承认事实要付出高昂的代价时，无论证据是多么地确凿，都会遭人质疑。这种的代价可能是 “都灵裹尸布” 里的宗教信仰冲突。但是更多的是与 &amp;ldquo;个人信誉&amp;rdquo; 冲突，即个人的 &amp;ldquo;对错&amp;rdquo;。
我向来认为自己是个坚定的唯物主义者，我相信科学，相信世界上的一切都有联系，相信人的一切行为都有原因。我看书的目的就是为了找到答案，这个答案不光光是 &amp;ldquo;质量足够大的物体可以扭曲空间&amp;rdquo;&amp;hellip; 更重要的是，我想知道为什么，我会做出一些自己难以理解的事情，或产生一些难以控制的情绪。最严重的事情就是，为什么我会如此执着于输出自己的想法并渴望得到别人的认可。我不希望这个答案是我父母给出的：你这个人太敏感，心思太重，想太多。现在我得到了另一个答案，这个答案是一位写出了 霸榜 30 年的畅销书的作者给出的，连他也说，这个是人类的天性，是进化演变而来的习性，没有这个习性的话，人类早就灭绝了。正因为遇到不确定或超出认知范围的东西会给我们的大脑带来警告，所以我们才得以规避这些风险。
可是，大脑给的信号，并不总是对的。偏见，有时连自己都意识不到。我又为什么这么相信自己的大脑？它越是要控制我的情绪，我越是要反着做。和同事对一件事有不同的意见，他坚定地反驳我，认为自己做的没问题，我虽不认同，但我也偏要笑着回复 &amp;ldquo;ok&amp;rdquo;。这不再是自我保护机制（告诉自己，一切与我无关，我只是个打工人）。而是，我要摆脱大脑对我的情绪控制，想让我争执，让我难受，我偏不。我就是要逆天性改情绪做自己。
最后，感谢这本书，让我绝望的同时，也让我找到了学习知识的另一个意义，那就是，让自己的心灵自由。</description>
    </item>
    
    <item>
      <title>君主论 - 不要中立</title>
      <link>https://lydiacai1203.github.io/post/the_prince_two/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/the_prince_two/</guid>
      <description>1. 中立的缺点
背景，法国路易十二扬言要从瑞士手中夺回米兰。马基雅维利认为意大利教皇应当支持法国而非保持中立。
1. 中立会让人觉得你优柔寡断，形式越急迫，越应当果断决断 2. 中立将自己置于两方都讨厌的境地，因为赢家不想要犹豫的朋友（在困难之际不愿意援助自己）而输家也不想要成为援助者（因为在你有能力帮助他的时候拒绝了他）。马基雅维利认为即使失败了，人们也会认为你有坚定的立场。 3. 优柔寡断会被认为是温和的不足以令人畏惧的对手。而一位君主在成为真正的队友或敌人时也会更受人尊敬。 （这是不是说明，只有实力足够强，才有资格保持中庸） 2. 什么时候选择中立
只有推迟决定对己方有战略性的优势时才可以采用
3. 决断的基本原则
马基雅维利认为，在处理自己的基本事务时，应当避免选择实力远比你强大的一方为友，因为如果他们赢了，你就是他们夺权的障碍。
3. 中立的思考
应当区分 缺乏勇气而保持中立 与 因慎重而远离事端 的区别。
在二战期间，两位法西斯独裁者，意大利的墨索里尼选择了希特勒，而西班牙的弗朗哥选择了保持中立，前者最后失败战争并丢失性命，后者则延续了自己的统治。万事万物都是很复杂的。战败国往往需要承担巨大的后果。</description>
    </item>
    
    <item>
      <title>君主论 - 爱戴还是畏惧</title>
      <link>https://lydiacai1203.github.io/post/the_prince_one/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/the_prince_one/</guid>
      <description>1. 古罗马将军 - 大西庇阿
被尊重 &amp;amp;&amp;amp; 不被畏惧
原因：他没有采取一些 有损于 自己名誉的军事或政治策略
后果：在西班牙，由于军机涣散发生叛变
环境背景：当时罗马人们认为善良慷慨，施以同情时高贵的品质而非不当的行为
作者点评：君主不应当介意为了子民的和平和忠诚而被称为残酷的人
2. 迦太基名将 - 汉尼拔
被尊重 &amp;amp;&amp;amp; 被畏惧
原因：异国作战 &amp;amp;&amp;amp; 军队种族复杂 &amp;amp;&amp;amp; 军队庞大
结果：没有针对他个人的叛变发生
作者点评：因为他的惨无人道和过人英勇，在士兵眼中他是一个所向披靡且可怕的人。如果没有残酷，其他的品质也难成气候
总结1 - 畏惧 优于 憎恶：
作为领袖和老板，只有勇气和擅长自己的工作，并不足以保证员工的忠诚。强权和纪律可以保证他们在自己的控制之下。好领导受人爱戴，而有实力的领导受人尊敬和拜服。
(Good leaders are admired, strong leaders are respected.)
太富有同情心会导致不安和混乱。残酷是另一种仁慈，汉尼拔残酷地将自己的人民从更可怕的政治暴乱中解救出来，这就不算残酷。仁慈可能会滋长暴乱和无序，最终伤及无辜。毕竟极限的刑法影响的只是少数人。
如果做不到两者兼具，那么 畏惧 优于 爱戴。因为恶是大部分人的本性，他们不懂得感恩且善变，既虚伪懦弱又贪得无厌。友谊是靠收买得来的，而不是靠美好的品行和高尚的思想。当危险来临时，侵害受爱戴的人的成本会比侵害受畏惧的人的成本低。因为爱戴会在人们自身利益受损时消失，而畏惧会被一系列残酷惩罚所加强，因而会一直有效。
总结2 - 被畏惧而不被憎恶:
马基雅维利发现，当君主不伤害子民的姓名和土地时，人们更倾向于顺从。当君主不得不加强纪律而侵害子民的性命时，惩罚的原因和公正性必须明确。因此应当只在必要时残酷。作者不建议剥夺人的财产，因为他认为，比起剥夺人的财产，原谅杀害自己的爱人会更快一些。
总结3 - 不能依赖人们爱戴的原因:
马基雅维利认为大部分人是自私的只为自身考虑的，他们只会支持为自己带来好处的君主。
最弱者依靠爱戴，而强者会使人民产生畏惧。最强者会在人民心中植入恐惧和爱戴，至少不是憎恶。因此君主以强制和决断为行动指导这一点很重要。</description>
    </item>
    
    <item>
      <title>安全开发指南（持续更新）</title>
      <link>https://lydiacai1203.github.io/post/sec_guide/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/sec_guide/</guid>
      <description>开发规范
腾讯 Python 安全指南
1. 代码实现 1. 避免使用不安全的对称加密算法（避免 DES/3DES，建议 AES） 2. 确保重要行为都记录在日志上，且可靠保存 6 个月以上 3. 禁止将未经验证的用户输入直接记录日志（防止注入漏洞：恶意用户插入伪造的日志数据，从而让系统管理员以为是系统行为） 4. 避免在日志中保存敏感信息（明文密码、密文密码 等等） 2. 系统口令 1. 禁止使用 空口令、弱口令、已泄漏口令 2. 口令强度需满足 + 密码长度大于 14 位 + 包含：大小写英文字母、数字、特殊字符 + 不得使用默认的初始密码 + 不能与最近 6 次使用过的密码重复 + 不得与其它外部系统使用相同的密码 3. 口令存储安全 + 禁止明文存储口令 + 禁止使用弱密码学算法加密存储口令 + 使用 不可逆算法 和 随机 salt 对口令进行加密存储 + 禁止传递明文口令 + 禁止在不安全的信道中传输口令 3. 配置 / 环境 1. 建议使用 Python 3.6+ 版本，因为 Python3 在 2020 年就停止维护了，相关漏洞不能得到及时修复和维护 2.</description>
    </item>
    
    <item>
      <title>Python 原生 SQL 如何预防 SQL 注入</title>
      <link>https://lydiacai1203.github.io/post/raw_sql_q/</link>
      <pubDate>Fri, 08 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/raw_sql_q/</guid>
      <description>什么是 SQL 注入 腾讯云博客 SQL 注入攻击是一种常见的Web攻击方法，攻击者通过把 SQL 命令注入到 Web 后台数据库的查询字符串中，最终达到欺骗服务器执行恶意 SQL 命令的目的。例如可以从数据库获取敏感信息，或者利用数据库的特性执行添加用户、导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。 2. SQL 注入例子 SQL 注入只会发生在字符串拼接的例子中，常见的攻击有拖库、拖表、篡改网页内容、收集数据库信息为其它攻击做准备等等。
假设代码中是这样一段代码 username = input(&amp;ldquo;enter in username&amp;rdquo;) sql = f&amp;quot;&amp;quot;&amp;quot; select * from content where create_user = &amp;ldquo;{username}&amp;rdquo; &amp;quot;&amp;quot;&amp;quot;
用户输入 username = &amp;rsquo;testc&amp;quot; or 1 = &amp;ldquo;1&amp;rsquo;, SQL 就会变成 sql = f&amp;rdquo;&amp;quot;&amp;quot; select * from content where create_user = &amp;ldquo;testc&amp;rdquo; or 1 = &amp;ldquo;1&amp;rdquo; &amp;quot;&amp;quot;&amp;quot; 3. SQL 注入预防通用方法
外部参数动态拼接 [&amp;quot;\&amp;quot;&amp;quot;, &amp;quot;\\&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;&#39;&amp;quot;, &amp;quot;=&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;#&amp;quot;, &amp;quot;;&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;&amp;amp;&amp;quot;, &amp;quot;$&amp;quot;, &amp;quot;(&amp;quot;, &amp;quot;)&amp;quot;, &amp;quot;%&amp;quot;, &amp;quot;@&amp;quot;, &amp;quot;,&amp;quot;] 过滤特殊符号 遇到固定格式的变量，在 SQL 执行前严格按照固定格式检查 特殊符号转义使用（SQL 中的转义字符是单引号） 参数化查询 绑定变量使用预编译语句（预防 SQL 注入的最佳方式） ORM 使用 ORM 避免 SQL 注入 存储 敏感信息加密存储 将 username = &amp;rsquo;testc&amp;quot; or 1 = &amp;ldquo;1&amp;rsquo; 中的特殊符号转译，除了左右两侧的单引号 这样 &amp;ldquo;testc&amp;rsquo;&amp;rdquo; or 1 = &amp;lsquo;&amp;ldquo;1&amp;rdquo; 就变成了一个值，而非表达式的一部分 sql = f&amp;rdquo;&amp;quot;&amp;quot; select * from content where create_user = &amp;ldquo;testc&amp;rsquo;&amp;rdquo; or 1 = &amp;lsquo;&amp;ldquo;1&amp;rdquo; &amp;quot;&amp;quot;&amp;quot; 4.</description>
    </item>
    
    <item>
      <title>骚渣一体 --《圆月弯刀》</title>
      <link>https://lydiacai1203.github.io/post/movie_szyt/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/movie_szyt/</guid>
      <description>老实说是冲 古天乐 和 梁小冰 的脸才去看的。看之前没想到味儿会这么冲。
看完这部电视剧我又去看了小说（不过没看完）。我想到以前还看过古龙的《陆小凤传奇》，貌似不是这么个味道啊。看的时候甚至一度让我以为古龙写这部小说的时候得了痔疮。直到后来去请教度娘，才知道古龙只写了 1/10，剩下的都是 司马紫烟 代笔的。淦，浪费我的感情。
电视剧改编了很多。讲的是男主丁鹏从小就特别崇拜在镖局打工的爸爸，觉得自己老爸的武功天下第一，谁知道有一次和小伙伴出去玩，半路正好遇到老爹在押镖，好家伙，说时迟那时快来了几个强盗，老爹啪一下就给跪了，不光跪了还尿了。小伙伴都笑话丁鹏。小丁鹏又羞又气回家了，从此以后拿着他爹捡来的 天外流星 的剑谱，在深山里刻苦练习。
要知道武侠小说里的男主要想出人头地，必须先父母双亡。丁鹏老爹坟头草都三米高的时候，丁鹏的 天外流星 也练的出神入化了。他决心要 出 人 投 地！于是就出山了，挑战这个挑战那个，都赢了。到了挑战万松山庄的 柳若松，谁知道这人是个阴险小人，派出自己的妻子秦可情去勾引丁鹏，用那一夜换取了那一页。柳若松得到天外流星的剑谱以后，破解了剑谱，打败了丁鹏。并说天外流星是自己自创的剑法，是丁鹏抄袭了。丁鹏百口莫辩，被逼的跳下了海。流落到了小岛，遇见了魔教公主，青青。两人互生情愫，丁鹏不仅入赘，还学习了魔教刀法 圆月弯刀，于是带着青青回中原找柳若松报仇。
再说秦可情和柳若松越过越憋屈，越过越觉得丁鹏才是真男人。于是当她再次见到丁鹏，她马上投怀送抱，答应里应外合，协助丁鹏复仇，把六大门派的武功心法秘籍全都刻到柳若松的密室里面。那边青青化身为蓝蓝，接近柳若松。让他四处杀人，然后教了他一套小学生剑法，骗其一定能打败丁鹏。最后？最后柳若松被废全身武功，当乞丐去了。
丁鹏心里一直想要雄霸天下，想要打败 剑神谢晓峰，成为天下第一。他把 姬无命 关了起来，假装自己是一直写诗给 谢小玉，勾搭上了谢小玉，继承了谢晓峰的武功，成为了神剑山庄的庄主。青青这边为了化解姬无命和丁鹏的矛盾，被柳若松害得瞎了眼睛。等她再见到丁鹏，已经是在丁鹏和谢小玉的婚礼上了。圣母心泛滥的女主当然是选择成全丁鹏啦。
丁鹏顺理成章成为武林盟主以后，青青老爸魔教教主出现了，一系列套路把丁鹏的命门捏得死死的，上演了一出无间道。鹏鹏子失去了一切，不干了，他发现自己心里唯爱青青，于是又去找青青。两人开了一个客栈，叫无命客栈，从此过上了隐居的生活。
本来写到这里真的可以了，但是魔教教主的结局还没写呀。说青青他爹来找丁鹏，让他交出弯刀。青青直到两人必有一死，于是易容成自己老爹去找丁鹏，被丁鹏干死了。丁鹏一看是自己老婆，不行啊，气的和他爹干了一架，俩人一起失踪了。留下一个儿子，丢给姬无命抚养。
写在最后，看完这部剧我最大的收获就是，原来 平平无奇的梗 是出自这部剧。之前我还一直以为是神雕侠侣里的。如果不是馋古天乐的颜，真的很不建议看，除非你想洗眼睛。</description>
    </item>
    
    <item>
      <title>Linux lsof 命令使用</title>
      <link>https://lydiacai1203.github.io/post/linux_lsof_usage/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/linux_lsof_usage/</guid>
      <description>为了以后查阅方便所做。 ------- 菜大头 lsof 简介 `lsof` 是 `list open files` 的简称。意思是 列出系统中打开的文件。由于 Linux 中 `everything is file`。所有的对象都可以看作是文件，`lsof` 就可以知道用户和进程都操作了哪些文件，也可以查看系统中网络的使用情况、设备信息。 lsof | head -n 20 会列出系统中所有打开的前20个文件，每个文件一行 FD cwd: 当前工作目录 txt: 应用文本(代码、数据) mem: 内存映射文件 mmap: 内存映射设备 TYPE REG: 普通文件 DIR: 文件夹 lsof -p 1190 打开 1190 进程打开的所有文件 lsof -u caiqingjing or lsof -u ^caiqingjing 打开某个用户打开的文件 or 除了某个用户.. lsof file_path 查看某个 文件/目录 被哪些进程打开 lsof +d dir_path 列出访问某个目录的所有进程 lsof -c nginx 列出某个命令使用的文件信息 使用 lsof 查看网络信息 lsof -i 列出所有的网络连接信息 lsof -i TCP -i 后面跟协议类型，只显示 TCP 网络协议的连接信息 lsof -i :80 查看 80 端口被哪个进程使用 lsof -i @172.</description>
    </item>
    
    <item>
      <title>Linux 内存管理</title>
      <link>https://lydiacai1203.github.io/post/linux_memory_manage/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/linux_memory_manage/</guid>
      <description>free usage (venv367) caiqingjing@ip-127.0.0.1:~$ free -h 总计 已用 空闲 共享 缓冲/缓存 可用 内存： 31G 7.1G 2.7G 105M 21G 23G交换： 0B 0B 0B 1. 关注 可用 列，估计有多少内存可用于启动新的程序而无须交换。 2. 理论上，used - buffers/cache 表示应用程序实际使用的内存？；free+buffers/cache 表示理论上可以被使用的内存。free 仅仅表示未被使用的内存大小。仅仅看 free 来判断是不够准确的。 3. 当可用内存接近 0 或 非常小时，已用内存接近总容量 时，意味这需要使用到交换磁盘了。可以使用 `grep -i kill /var/log/messages *` 或 `dmesg | grep oom-killer` 检查内存溢出日志消息。 缓存（cache） read_cache:读文件时，通常需要将硬盘里的数据读入内存，但是硬盘和内存的读取速度相差太多，因此 linux 会将数据读入 cache 中，然后从 cache 中读取需要的数据。当一个缓存中的数据被多次读取，实际上就减少了该数据从慢速设备中读取的次数。因此 cache 中的数据是随机访问的特性。write_cache:与 read_cache 对应，它的目标应该是减少写入慢速设备的次数。使用 cache 的话，可以多次写入 cache, 但是只写入一次硬盘。 缓冲（buffer） read_buffer: 每当 buffer 满或者主动 `flush` 时会触发一次读取，对于小数据可以减少读取次数，对于大数据可以控制单次读取的数据量。通常来说，先入 buffer 的数据会被先读取，所有的 buffer 数据几乎一定会被读取，拥有顺序访问的特性。write_buffer:同上，也是需要 buffer 满或者主动 `flush` 时才会触发写入。如果每次写入的数据量相对固定。因为如果一次写入 4k 对与某个设备来说效率最高的话，buffer 一定是 4k。小数据积攒到 4k 写入，大数据分割成 4k 的碎片写入，这是 write_buffer 的用处。 交换内存（swapping） 当主存(RAM) 不足以临时存储多个程序时，我们从 RAM 中取出一些程序，通过 swap out 的机制将它们存储到硬盘中。当 RAM 可用时，我们再次将程序从硬盘交换到 RAM, 这就是 swap in。Linux 中的交换空间是物理内存的两倍。优点： 1.</description>
    </item>
    
    <item>
      <title>断点续传的原理</title>
      <link>https://lydiacai1203.github.io/post/download_file/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/download_file/</guid>
      <description>参考文档
1. 什么是断点续传？ 可以让用户从上一次下载中断的位置接着下载的机制。 2. 断点续传的原理 1. `curl -I {url}` 查看响应头部是否有 `content-range` 字样，有则代表服务端支持断点续传功能。 2. HTTP HEADERS 1.1 Range(在有 If-Range 的时候才会生效) * Range: bytes=0-1023 请求资源的前 1024 个字节 * Range: bytes=-1023 请求资源的倒数 1023 个字节 * Range: bytes=1023- 请求资源第 1024 字节开始及以后的资源 * Range: bytes=0-50, 100-150 请求资源的多个部分 1.2 If-Range(必传两个中的一个，但不能同时传) 1.2.1 Etag * 675af34563dc-tr34 * 文件资源的唯一标示，一个字符串 1.2.2 Last-Modified * If-Range: Wed, 21 Oct 2015 07:28:00 GMT * 上一次文件资源修改时间 3. RESP HTTP STATUS CODE 3.1 206 - Partial Content（此次请求成功） 3.</description>
    </item>
    
    <item>
      <title>Elasticsearch2.x 权威文档 （摘抄）</title>
      <link>https://lydiacai1203.github.io/post/es_doc_readingnote/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/es_doc_readingnote/</guid>
      <description>Elasticsearch2.x 权威文档 （摘抄） 很多用法都已经过时，看完这个我打算再看一下 7.x。仅作为快速查阅的工具文档使用，可能不会和原文一致。希望尽量做到精简。 有一些模块因为暂时使用不到所以选择不看，毕竟没有应用的情况下是很容易忘记的。
面向文档 Elasticsearch 是 面向文档 的，意味着它存储整个对象或文档，Elasticsearch 不仅存储文档，而且 索引 每个文档的内容，使之可以被检索。在 Elasticsearch 中，我们对文档(而不是对行列数据)进行索引、检索、排序、过滤，这也是 Elasticsearch 能支持复杂全文检索的原因。
JSON Elasticsearch 使用 JavaScript Object Notation (JSON) 作为文档的序列化格式。具体可以看 serialization 和 marshalling 两个处理模块。
几个名词 索引 .n 一个索引类似于一个数据库，是一个存储文档的地方。 索引 .v 索引一个文档就是存储一个文档到一个索引中以便于被检索或是被查询。类似于 insert, 当文档已存在时(_id已有) 会进行更新。 倒排索引 倒排索引被作用在文档上，以便于提升数据的检索速度。默认的，文档中的每一列都有倒排索引，没有倒排索引的属性是不可能被搜索到的。 检索文档 GET - /index/mapping/id 即可检索出 ID 对应的对象
GET - /index/mapping/_search 用于检索所有的对象(一个搜索默认返回十条结果, 放在 hits 中)
GET - /index/mapping/_search?q=alst_name:Smith – URL 查询参数查询
GET - /index/mapping/_search – 进行查询表达式搜索(部分匹配)
{ &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;last_name&amp;#34;: &amp;#34;Smith&amp;#34; } } } GET - /index/mapping/_search – 组合过滤查询 { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;must&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;last_name&amp;#34;: &amp;#34;smith&amp;#34; } }, &amp;#34;filter&amp;#34;: { &amp;#34;range&amp;#34;: { &amp;#34;age&amp;#34;: {&amp;#34;gt&amp;#34;: 30} } } } } } GET - /index/mapping/_search – 全文搜索 { &amp;#34;query&amp;#34;: { &amp;#34;match&amp;#34;: { &amp;#34;about&amp;#34;: &amp;#34;rock climbing&amp;#34; } } } Elasticsearch 默认按照相关性得分来进行排序，即每个文档跟查询的匹配程度。而且上面这个查询甚至会把只有 rock, 没有 climbing 的也匹配出来。这是完全区别于传统关系型数据库的一个概念，一条记录并不是要么全匹配，要么全不匹配，es 是部分匹配。</description>
    </item>
    
    <item>
      <title>GIT 常用命令查阅手册</title>
      <link>https://lydiacai1203.github.io/post/git_command/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/git_command/</guid>
      <description>练习平台 - 强烈建议新手通关
git commit 将当前版本和仓库的上一版本进行对比，将所有的差异打包到一起作为一个提交记录。 git branch &amp;lt;branch_name&amp;gt; 创建分支 git merge &amp;lt;branch_name&amp;gt; git rebase master 将 bugFix 里面的 commit 按照顺序复制到 master 下。也就是说 bugFix 在 master 分支的最顶端了。 git checkout master git rebase bugFix # 相当于将 master 的 commit 复制到 fixBug 下，master 会在 bugFix 的顶端，所以 master 只会往下移一格。 HEAD 总是指向当前分支上最近一次的提交记录。 HEAD 通常情况下指向分支名的。 也就是说 master 分支其实是 master 指针，head 指针是单独的 head 指针。 `git checkout &amp;lt;commit-sha&amp;gt;` 便可以移动 head 指针。 cat .git/HEAD git symbolic-ref HEAD 这两句可以查看当前的 HEAD 指针指向 ^ 相对引用，n 个 ^ 或者 ~n 就是向上 n 个 commit git checkout master^ 或者 git checkout HEAD~4 git branch -f master HEAD~3 强制修改分支位置，将 master 分支强制指向 HEAD 的第三个父级提交。 git reset HEAD~1 通过分支记录回退几个提交记录来实现撤销改动。 git revert HEAD 通过在要撤销的提交记录后面新增一个提交，然后在新提交里面引入一些更改，这些更改便是用于撤销记录的。 git cherry-pick 将一些提交复制到 HEAD 下。 交互式的 rebase 如果你不知道要提交的 sha 值，就可以使用交互式的 rebase.</description>
    </item>
    
    <item>
      <title>两种权限系统，主要是吐槽设计</title>
      <link>https://lydiacai1203.github.io/post/record_of_a_destroy/</link>
      <pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/record_of_a_destroy/</guid>
      <description>过年那段时间真的太难受了。这期间遭受了很多事情。 但是我现在记不住太多东西了。朋友圈里多了很多人，三家公司，三家公司的同事。我不能和以前一样在里面抱怨什么了。赖哥的骚操作积累的太多，我都写不完。
安全运营平台当时设计权限系统的时候，权限上分了两部分，一个是功能权限，一个是数据权限。功能权限控制是否能访问接口，数据权限控制返回的数据，不具有完全的数据权限的只会返回部分数据。考虑到用户配置的方便性，还有工时等限制，最后采用了参数控制的方式。这样说不是很直观，下面简单说明一下权限表的设计。
id perm_name perm_key perm_args created updated status 1 地址标签库 - 黑地址标签 - 读 black_address_tags_read category=1, 2, 3&amp;amp;status=1 2020-01-01 00:00:00 2020-01-01 00:00:00 1 id role_name created updated status 1 super_user 2020-01-01 00:00:00 2020-01-01 00:00:00 1 id role_id perm_id created updated status 1 1 1 2020-01-01 00:00:00 2020-01-01 00:00:00 1 id user_name created updated 1 caiqingjing 2020-01-01 00:00:00 2020-01-01 00:00:00 id user_id role_id created updated 1 1 1 2020-01-01 00:00:00 2020-01-01 00:00:00 id user_id perm_id created updated 1 1 2 2020-01-01 00:00:00 2020-01-01 00:00:00 应用场景：</description>
    </item>
    
    <item>
      <title>Study Tips(2019&#43;2020)</title>
      <link>https://lydiacai1203.github.io/post/study_tips_2019/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/study_tips_2019/</guid>
      <description>1.10:57 完成了人生中第一次服务器购买以及成功地翻出了墙.
2.解决了一个关于使用gunicorn打印不出日志的问题
3.破解了银保监的反爬，学到很多东西
4.将html转成pdf的简便方法，用chrome打开html，ctrl+p就可以转化成pdf了
5.mongodb创建联合索引create_index([(field, 1), (field2, -1)])
6.原来除了有os.system()直接执行command,还有os.popen()，原理是创建一个管道，然后可以这个管道里标准输出流里的东西拿出来，拿到return的对象，fp.read()即可，用完fp.close()
7.遇到了一个坑，使用phantomjs的时候，比较慢，所以我希望这玩意只有一个，就弄成了全局变量，结果，发现driver.quit()失效了，根本没关闭上，这就很恶心人了。 解决方法是弄成局部变量
8.假如问你：cookie和session的区别 你知道怎么回答吗 反正我是重新认识了cookie,而且最让我惊讶的是，问了好多同事，给我的回答竟然都是和我面试的时候是一样的回答。我有时候不禁会想，面试官在问我这个问题之前，自己是否也清楚cookie和session的区别呢&amp;hellip;..又放肆了，还是好好学习吧
9.markdown里面如果想使用空行的话，可以使用html里面的br标签，但是要在br标签的前后都给到一个空行，在github上面显示才比较好看。或者使用空格+空格+换行，也可以达到一样的效果
10.mysql5.6 的 最左前缀优先 和 mysql5.7 的 最左前缀优先不一样，比如说现在有一个联合索引(name, cid), 有一条查询语句：select * from tablename where cid=1;这条语句在5.6中就不会走索引，但是在5.7中会走索引
11.今天知道一个新的markdown语法，[TOC] 可以自动按照生成目录，但是github不支持
12.set里面允许放的是不可变对象, 什么是不可变对象(string, numbers, boolean), 同理dict的key也是。这个fluent-py里面有讲解。加入我现在有两堆对象，我想做一个交集。但是我不想用for循环一个一个去比对。这个对象的数据成员都是由基本类型组成的。对象显然是放不进set里面的，这时候只需要实现__hash__和__eq__，具体解释就不在这里写了，但是，但是，但是，你想要去比对，肯定是和__eq__有关系，所以在实现__eq__的时候，势必要结合具体的业务情况。这时候就可以愉快地做交集并集了。
13.之前研究了网页编码，一开始都是采用了resp.text，后来发现其实requests底层使用的是resp.encoding, 这个encoding的默认值取的是response.headers里的content-type中charset这个值，如果没有这个值呢，requests就会使用chardet进行编码判断(也就是get_encoding_from_headers)后来发现这个方法呢，其实并不好用，取出来的是个ISO-8859-1，这个东西解码字节数组以后也不对。又发现有一个get_encodings_from_content,这个是从html里面的meta里面取charset这个值。有些html会有多个meta标签，所以这个函数会取出多个charset，也就是一个列表。这个就要自己取取舍了。一般我认为如果是ISO-8859-1的话，就是用UTF进行编码，如果gb打头，就是用gb18030进行编码。因为gb2312&amp;lt;\gbk&amp;lt;\gb18030。另外很多时候，会出现一种情况就是，明明charset是对的，但是使用decode(charset)的时候会报错。这是因为网页中含有一些这个编码不可以解析的字符，是什么原因我不知道，但是可以使用decode(charset, &#39;ignore&#39;)，只显示那些能编码的字符。
14.虽然之前也遇到过supervisor装好了以后出现各种问题，今天尤其仔细地看了一下解决的方法，记录一下
supervisord -c /etc/supervisor/supervisord.conf 报错：Unlinking stale socket /var/run/supervisor.sock find / -name supervisor.sock # 全盘搜索这个文件名 unlink /**/supervisor.sock supervisord -c /etc/supervisor/supervisord.conf # 再重启supervisord服务 15.Python设计和历史常见问题
16.一个可以拿到访问者ip的接口
17.what-cicd
18.一些好用的网站？
在线ps
周读
临时邮箱
工具网</description>
    </item>
    
    <item>
      <title>docker image的实现原理以及registry相关的一块知识</title>
      <link>https://lydiacai1203.github.io/post/analyse_image_layer/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/analyse_image_layer/</guid>
      <description>part_one: 什么是文件挂载？ 1. Unix里面的文件目录是目录树结构的形式，所有的文件目录都是基于硬盘disk逻辑抽象出来的。比如现在有一个的一个目录。
接1. 现在要把这些文件目录挂载到磁盘上面，在linux的文件系统里面，首先执行mount命令进行文件挂载，比如说将/(根目录)挂载到disk1里面，挂载完了以后，根目录下的进行创建操作或是写操作的时候，数据文件都会存储在disk1当中。
重点来了。比如说现在在data目录下创建一个文件a.txt, 这时候将/data挂载到disk2下面，这时候disk2中是看不到a.txt的。
part_two: 联合挂载 那么既然有要挂载以后再写才能看见的挂载，肯定有写完以后再挂载依旧能够看见之前已经写了的文件的挂载方式。docker layer就是属于这种。
part_three: docker 的layer和image的关系就有点像联合目录以及挂载点 也就是说，一个image代表的就是layer中的一个挂载点，而所有的layers就像是一个联合目录。
最先进行build的layer层就在栈底，同样最后build的layer层就在栈顶。比如说现在在layer1层进行touch a.txt和touch b.txt两个动作(要注意现在图中所示的所有layer层都是read-only)。layer2层进行touch a.txt。那么这个时候整个docker image build以后，使用这个image生成的实例以后，这个实例里面存在的是哪一层的a.txt。
这就涉及到所谓的联合挂载了。也就是说当前的docker image 看得到之前的 docker image创建的全部的layers。现在请注意，接下来是重中之重，涉及image实现原理。课代表请记笔记。(我真的是个戏精)
part_three: docker image 实际上是怎么实现的 上个部分说到docker image是由很多个layer组成的，且这些layer是read-only的。每当生成一个新的实例以后，就会在栈顶增加一个writable-layer层。实际上是复制了一份read-only-layer中的数据到writable-layer中, 在container中修改的是这一层writable-layer中的数据。
好了，现在已经扯远了，回到问题上来，实际上一个docker image是由两部分组成的，分别是Manifest(layer_name list)和image_name(image_name: name:tag)
layer list中的每一个item，都是一个由hash(layer_content)=sha-256的这样一个hash值组成的。这样的hash有三个优点：1. 分布均匀；2. 碰撞少；3. 容易出现雪崩效应(所谓的雪崩效应输入值稍微改动一点点，hash值就会产生巨大的变化，这也是导致分布均匀的原因之一)。ps:Manifest也可以理解为是文件清单的意思。register(docker中的仓库)中其实存放了很多很多很多很多无序的layers。
part_four: 如何实现的layer不重复下载？ 当我们build Dockerfile的时候, 首先会根据Dockerfile生成一张Manifest的表。里面存的是一堆的hash值。会根据这张表从栈顶开始查，查到栈底，这个hash值实际上可以理解为是digest, 通过和本地layer的sha-256值进行比对判断有没有必要再创建一个。
part_five: 回到一开始的问题，生成的contianer里面到底是那个layer的里的a.txt 再回到文件系统来说，启动一个容器的时候，可以看到容器里面是有一个完整的文件系统的，容器里面的所有文件都来自构成镜像的层。每个层里面都有文件。Docker通过aufs的技术，把所有的层都挂载到了同一个目录上(所以现在知道，所谓digest其实就是，把所有layer里面的文件打包压缩求hash)。 也就是这时候container会从栈顶往下开始找文件，走到layer2的时候找到了a.txt, 这时候就不会用到layer3中的a.txt, 而是加载b.txt。所以说container里面的其实是a,txt文件。</description>
    </item>
    
    <item>
      <title>what is k8s?</title>
      <link>https://lydiacai1203.github.io/post/what_is_k8s/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/what_is_k8s/</guid>
      <description>part_one: 基本结构介绍 Node可以理解为物理资源，在K8s里面可操作的最小单元就是Pod，我们可以通过配置Pod配置文件的template字段来控制一个Pod里面有哪几种Container，但是不能控制一个Pod里面有几种container。Pod配置里面的template说明了要启动的容器是怎么样的，最重要的就是image的信息。
后来由于需要部署的服务越来越多，每个Pod都是人工手动启动或者是删除检查的。所以后来产生了ReplicaController，有了这个东西以后就可以指定每个服务所要启动的Pods。这里的selector就是现在RC管理的下，还有哪些Pod是存活的。然后template就是指的是要启动的Pod是什么样子的。
但是后来又遇到了滚动升级的问题(滚动升级：比如现在一个服务要从v1升级到v2，当时人工的处理方法就是将v1的Replica:3-&amp;gt;Replica:2, 然后将v2的配置文件里面配上Replica:1，后续的动作依次类推)。这样也耗费了大量的人力。
所以这时候Deployment就出现了，但是由于ReplicaController还有一些涉及的不好的地方，所以为了更好地与Deployment进行配合，于是就出现了ReplicaSet。
所以Deployment就是控制ReplicaSet的，Deployment里面可以看见RS和Pod两个东西的内容。
Pod在K8s里面，这是一个不稳定的东西，每次死掉以后再挂起来，Pod的IP都会发生变化。那怎么去准确地找到哪一个Pod呢？(这个和endpoint也有一点关系)但是一个服务起了多个Pod，这时候如果有流量过来应该分配给哪个Pod呢？于是就出现了Service，这个Service起到了一个所谓的负载均衡的作用。每一个Service在这个集群里都有唯一确定的IP，这样就可以找到一群Pods，然后每个Pod都由endpoint进行标识。
但是Service还是在这个虚拟网络里面的，外面用户来的流量应该怎么对应到指定的Service上面呢。之前说到外网想要连到百度云的服务器所在的私网的时候，使用的是VPN。但是我们不可能让用户都装上一个VPN Client。都进行验证。都建立一个虚拟专用网络。所以就出现了IngressController。这个东西可以简单地理解为是Nginx，可以实现反向代理。
外部的流量会直接访问域名通过ip查询会命中Nginx中配置当中的public ip，这时候会把流量导向Service。但是这个对应的实现就是，Ingress实际上就是一种映射机制，定义了映射规则。在IngressController里面存在这一份vhost,这个里面存在service_ip和port的映射。这样就可以实现外部网络访问内部对应的pod了。</description>
    </item>
    
    <item>
      <title>what is NFS?</title>
      <link>https://lydiacai1203.github.io/post/whatis_nfs/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/whatis_nfs/</guid>
      <description>part_one：一台物理机器上的文件存储 计算机里面有很多块磁盘，计算机里面的文件系统都是逻辑树状结构的，逻辑上的概念都是物理中不会出现的。一个一百兆的文件在计算机上有几种存储方法。简单地来说有两种:
1. sequence 在disk中占有一段连续的存储空间。这样做的好处有几点：一是简单方便；二是命中率高，因为程序的局部性原理。命中率高会导致读的速度比较快。但是这样做也是有坏处的，坏处就是这样存储文件容易出现磁盘碎片。因为不太容易找到100M这么大的连续存储空间。
2. Inode=index+data_node 这种方式会讲一个disk分成两个部分，一个部分是index表头，一个部分是很多很多的data node，这些data node的大小一都是可以设置的，一般的大小在4KB-&amp;gt;16KB。一个100M的文件会被分成好几个部分，被存储到不同的node里面去。然后在index表头里面做一个地址的记录。这样当把这个disk挂载到某个目录上面去的时候，文件系统要显示这个disk中的所有的文件，去找的时候就会根据这个index的表头去拼出一个完整的文件。
part_two：什么是NFS？ NFS的Network FileSystem，中文意思是分布式网络文件系统。这个出现的原因是因为，当目录下的文件非常多的时候，有可能会出现一个物理机里的磁盘存不下的情况。所以这种时候就出现了NFS。
拿一个例子来讲，所有远程registry里面的images的layers都是乱序的，且不可能只是存在于一台物理机上面。
1. 首先layers很多很多，不够存。
2. 其次就是必须看见的是一个文件系统，因为layer是被image各种交叉引用的。现在有一个NFS,做了一层隔离，一个文件可能分成几块存在不同的物理机的disk上面，然后这个NFS在显示文件目录下面的挂载情况的时候会将所有的物理机磁盘里的文件拼在一起展示在挂载的文件目录里面。造成一种假象。
3. NFS只是一种协议规范，真正实现这种规范的有GFS, GlusterFS, MooseFS等等，其中MooseFS就是所说的MFS，也就是公司现在用的这种分布式网络文件系统。
part_three: 磁盘阵列的好处 磁盘阵列会在你将数据写入一个磁盘的时候，同时同步到另一个磁盘上去。这样读写文件的速度就会变成两倍速。一个磁盘上从头开始读。另一个磁盘上从百分之五十的地方开始读数据。那可不可以说设置两个指针，一个在文件头，一个在文件尾进行读写呢，这样做会收到磁盘吞吐量的约束，所以也是一种有问题的做法。</description>
    </item>
    
    <item>
      <title>看完 天龙八部 以后，有一点骚话想说</title>
      <link>https://lydiacai1203.github.io/post/movie_tlbb/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://lydiacai1203.github.io/post/movie_tlbb/</guid>
      <description>我大概是疯了，从周日开始看到周一凌晨，终于把《天龙八部》给刷完了。
虚竹的故事线一条下来，我也觉得尚能接受。分支故事线应该就是天山童姥和李秋水，为了无崖子，一个划花对方的脸，一个在对方修炼神功的时候搞偷袭，还都觉得无崖子喜欢自己，结果无崖子喜欢的是李家小妹。虚竹也是个挂比，也算积善缘得善果，珍珑棋局为了救段延之误下一子，然后得段延之相助破解了珍珑棋局，得到了无崖子七十多年来的深厚内力，最后又因为一颗救人积善之心，结缘童姥，学会天山折梅手和天山六阳掌。也是因为阻止童姥和李秋水掐架最后误打误撞得到两人的内力，最后成为灵鹫宫主人。这样一个挂比小和尚，金庸也要给他安排上一段香艳场景，虽然梦姑梦郎终成眷属，但我总觉得冰窖中的那段描写像是一种意淫。虚竹的身世似乎也必须离奇，原来是玄慈与叶二娘的儿子，一天之内与父母相认，又一天之内失去双亲。
段誉也是一个名副其实的挂比+一个情商巨高的舔狗。先是因为救钟灵被灵鹫宫天使打落悬崖误打误撞习得凌波微步，接着又因为回头寻找小黑马主人而结识木婉清，去救木婉清的时候又把北冥神功给学会了，一不小心就吸了这个，吸了那个。跪舔王语嫣又别出心裁，不像宋青书那个蠢猪，当准备用六脉神剑下死招给慕容复的时候，还想到王姑娘会不会因此而不开心，可是宋青书这个蠢猪在张无忌身负重伤别人都不好意思上千补刀的时候，他还不自量力地想把张无忌干死。可谓是舔狗中的失败范例。同为舔狗的还有游坦之和阿紫，因为舔错了方式，而无法和自己心爱的人在一起。段誉还真的和段正淳一样，风流多情，原来三个爱人都是段正淳的女儿，正当我以为段誉要孤独一生的时候，故事又峰回路转，段誉竟然是段延之的儿子。我tm&amp;hellip;
自带音响的男人乔峰（萧峰）在喝断义酒的时候我真的心里难过极了，就不说了，大英雄谁都喜欢。虽然我看不太懂他为什么会爱上阿朱。
如果要我说我最喜欢谁，我应该最喜欢的是鸠摩智，典型的学霸，虽然有一丢丢急功近利，但是最后大彻大悟成为得道高僧也是相当有悟性有天赋的人，也是金庸没有给安排什么奇怪的感情线的人，所以我喜欢他。
就这样吧，我感觉金庸的其它作品我短期内应该都不会再去看了。</description>
    </item>
    
  </channel>
</rss>

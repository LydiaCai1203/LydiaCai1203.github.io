<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hugo Cactus Theme</title>
    <link>https://lydiacai1203.github.io/post/</link>
    <description>Recent content in Posts on Hugo Cactus Theme</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 07 Aug 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://lydiacai1203.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>聚类算法原理</title>
      <link>https://lydiacai1203.github.io/post/clustering_algorithm/</link>
      <pubDate>Wed, 07 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/clustering_algorithm/</guid>
      <description>1. K-means（EM 算法） 1. 概念 存储用于定义聚类的 K 个质心。点离哪个质心最近，就被认为属于哪个类; K-means 通过交替进行以下两步找到质心： 1) 根据当前质心划分数据点; 2) 根据当前数据点计算聚类的质心; 2. 算法详解 1) 初始化质心，通常会随机选择 K 个数据点 2) 将每个点归类，离哪个质心最近，就属于哪一类 3) 计算当前簇类的平均值，找到新的质心 4) 重复 2、3 步 3. WCSS(Within-Cluster-Sum-Of-Squares) 每一个数据点到其所属质心的距离的平方和，就是 WCSS。 4. Elbow Curve x 轴就是 K 值，y 轴就是 WCSS, 画出曲线。将其中下降剧烈的点称为肘点，肘点对应的 K 值就是最佳 K 值。 5. 优点 1) 适合高斯分布数据集 2) 适合同质数据 3) 适合聚类之间界限清晰，不重叠的情况 4) 适合中等大小的数据集 6. 缺点 1) 不适合复杂分布的数据集 2) 需要提前预设 K 值，最优解查找不佳 3) 不适合大数据集，计算成本高昂 4) 对初始中心敏感，容易受到数据中的噪声和异常值的影响 5) 对噪声和异常值敏感 7.</description>
    </item>
    <item>
      <title>家、私有制和国家的起源</title>
      <link>https://lydiacai1203.github.io/post/thinking_4/</link>
      <pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/thinking_4/</guid>
      <description>Chapter1. 史前各文化阶段 1. 蒙昧时代 1.1 低级阶段 人们住在最初居住的地方(可能是树上，以此躲避大型猛兽)，以果实、坚果、根为食物，音节清晰的语言是这一时期的主要成就。&#xA;1.2 中级阶段 以鱼类等水栖动物作为食物 &amp;amp;&amp;amp; 适用火源。至此人们不再受到气候和地域限制，分散在大部分地面上。遍布各大洲的旧石器时代的石器，就是最好的证明。棍棒和标枪的发明，人们可以打猎获取食物，但这种方式的食物来源经常没有保证，因此此阶段大概率发生了食人风气。&#xA;1.3 高级阶段 有了弓箭，猎物成了通常的食物，且发明这些工具需要长期积累的经验和较发达的智力。弓箭对于蒙昧时代，正如铁器对于野蛮时代，火器对于文明时代，是决定性的武器。&#xA;2. 野蛮时代 2.1 低级阶段 制陶术出现。&#xA;2.2 中级阶段 野蛮时代特有的标志，是动物的驯养、繁殖、植物的种植。在东大陆，有适合驯养一切动物和植物的条件。但西大陆(美洲)，只适合驯养羊驼和种植玉米。因此 东大陆 从驯养家畜开始，而西大陆是从种植以及用石头建造开始。&#xA;畜牧的形成，导致了游牧生活的出现。肉乳食物对儿童发育有着有利影响，脑子会比不得不吃素食的人要大一些。&#xA;2.3 高级阶段 从铁矿石的冶炼开始，并由于拼音文字的发明及其应用于文献记录，而过渡到了文明时代。这时期出现了牲畜使用的犁，这样就可以大规模耕种土地，使得生活资料在当时的条件下可以无限制增加，人口也得以迅速增长，稠密地聚居在不大的地域内。&#xA;野蛮时代高级阶段的全盛时期，在 荷马史诗 中得以窥见。这个时期已经有了货车、战车、船、城市等等。&#xA;最后我们可以把摩尔根的分期概括如下：蒙昧时代是以获取现成的天然产物为主的时期；人工产品主要是用于获取天然产物的辅助工具。野蛮时代是学会了畜牧和农耕的时期，学会靠人的活动来增加天然产物生产的方法的时期。文明时代是学会对天然产物进一步的加工，是真正的工业和艺术的时期。&#xA;Chapter2. 家庭 摩尔根发现，对血缘亲属关系的亲疏以及辈份的观点和表达，可以表达单个人的数百种不同的亲属关系。这些称呼代表着完全确定的、异常郑重的相互义务，这些义务的总和构成这些民族的社会制度的实质部分。&#xA;根据称呼，摩尔根发现易洛魁人中，男子过着多妻制的生活，女子过着多夫制的生活，他们俩者的子女被视为大家共有的子女。&#xA;高等动物的群和家庭是相互对立的，因为雄性在交尾期内的嫉妒会削弱或暂时瓦解任何共同生活的群。因此，在自由的性关系或多偶制盛行的地方，群差不多是自动形成的。为了使群能组成，家庭的纽结必然要放松，个体必然要重新自由。&#xA;人类为了在发展过程中脱离动物状态，就需要以群的联合力量和集体行动来弥补个体自卫能力的不足。这需要成年雄者的相互宽容、没有妒忌，才是形成较大的持久的集团的首要条件，只有在这样的集团中才能实现由动物向人的转变。我们发现的历史上最古老、最原始的家庭形式，就是群婚。即整群的男子与整群的女子，互为所有。再晚些时候甚至出现了多夫制。&#xA;这个时期摩尔根称为，杂乱的性关系时期。在这一时期发展出了以下几种家庭形式。&#xA;血缘家庭 这一家庭形式中，仅仅排斥了祖先和子孙之间、双亲和子女之间互为夫妻的权利和 义务。同代人互为夫妻。这一家庭已经绝迹。&#xA;普那路亚家庭 普那路亚家庭形式即一列或者数列姐妹成为一个公社的核心，她们的同胞兄弟则是另一个公社的核心。在这个公社里，互为彼此的丈夫和妻子。只是在血缘家庭的基础上排斥了同代人互为夫妻的关系。这是由于自然选择在发生作用。禁止近亲结婚的部落一定比那些允许近亲结婚的部落发展地更迅速和完全。&#xA;在一切形式的群婚家庭中，谁是孩子的父亲是不确定的，但谁是孩子的母亲是确定的。即使母亲把共同家庭里的一切子女都叫做自己的子女，对她们都担负母亲的义务，但她仍然能够把自己亲生的子女同其它一切子女区分开来。由此可知，只要存在群婚，那么世系就只能从母亲方面确定，因此只能承认女系。&#xA;对偶制家庭 由于婚姻禁规日益复杂，群婚越来越成为不可能，群婚就会被对偶制家庭所排挤。&#xA;对偶制是某种或长或短 时期内的成对配偶制。这一阶段，一个男子和一个女子共同生活；但多妻和偶尔的通奸仍然是男子的权利；同居期间要求妇女严守贞操，否则便残酷责罚；婚姻关系很容易由任何一方解除，而子女仍然只属于母亲。&#xA;随着对偶制的发生，女子便稀少起来，因此出现了抢劫和买卖妇女的现象。&#xA;这种对偶制家庭，本身很脆弱，不稳定，无法使人需要有或者只是希望有自己的家户经济，因此它根本没有使早期传下来的共产制家户经济解体。共产制家户经济意味着妇女在家内的统治。妇女不仅居于自由的地位，而且受到高度崇敬。在共产制家户经济中，大多数或全体妇女都属于同一氏族，男子来自不同氏族，这种共产制家户经济是原始时代普遍流行的妇女占统治地位的客观基础。&#xA;从群婚到对偶制的过渡，是妇女用这种办法，把自己从旧时的共夫制之下赎出来的，而获得了只委身于一个男子的权利。这种过渡主要是由妇女所完成的，是绝对正确的。古代遗传下来的两性间的关系，越是随着经济生活条件的发展，从而随着古代共产制的解体和人口密度的增大，而失去森林原始生活的素朴性质，就必然越使妇女感到屈辱和压抑；妇女也就必然越迫切地要求取得保持贞操的权利，取得暂时地或长久地只同一个男子结婚的权利作为解救的方法。&#xA;对偶制 -&amp;gt; 专偶制 的过渡(家长制家庭) 这个阶段，畜群已经完全转归家庭所有，妻子也具有了交换价值。家庭并不像牲畜一样可以迅速繁殖。此时奴隶制度已经发明了，美洲印第安人处置奴隶的方式，男的杀死或收编胜利者的部落，妇女则作为妻子连同起子女收编入族。奴隶也可以看管越来越多的牲畜。&#xA;这类对偶婚，按照当时家庭内部的分工，丈夫的责任是获得食物和为此所必须的劳动工具，妻子保留家庭用具。在离婚时，丈夫就会带走劳动用具(包括家畜、奴隶)，妻子保留家庭用具，不过子女仍然无法继承他的财产。这些财富一旦转归家庭私有并迅速增加起来，就给了以对偶制和母权制氏族为基础的社会一个强有力的打击。&#xA;随着财富的增加，财富便一方面使丈夫在家庭中占据了比妻子更重要的地位；另一方面又产生了利用这个增强了的地位来废除传统的继承制度，转为有利于自己子女的原动力。因此母权制也就必须被废除了。&#xA;母权制被推翻，丈夫在家中掌握了权柄，妻子被贬低、奴役、变成单纯的生孩子的工具。这在英雄时代，尤其是古典时代的希腊人中间，表现地尤为露骨。这一时期出现了家长制家庭，指若干的自由人和非自由人在家长的父权之下组成了一个家庭。这个家长过着多妻的生活，非自由人也有妻子和子女，而整个组织的目的在于在一定的地域范围内照管畜群。Fimilia 这个词，在罗马人那里，起初甚至不是指夫妻及其子女，而是指奴隶。Famulus 是一个家庭的奴隶，Fimilia 指属于一个人的全体奴隶。罗马的父权，支配着妻子、子女和一定数量的奴隶，并且对他们握有杀生之权。&#xA;马克思说，现代家庭的萌芽，不仅包含着奴隶制，而且包含了农奴制，因为它一开始就是同田野耕作的劳役相关。以缩影的形式包含了一切后来在社会及其国家中广泛发展起来的对立。这种家庭形式表示着从对偶制到专偶制的过渡。为了保证妻子的贞操，从而保证子女出生自一定的父亲，妻子便落在丈夫的绝对权力之下了，即使打死了她，也不过是在行使他的权力罢了。&#xA;多妻制 和 多夫制，是历史的奢侈品。排除在多妻制以外的男子也并不能从因多夫制而成为多余的妇女那里求得安慰，而且男女的数目，不管社会制度如何，迄今又差不多是相等的，所以无论是 多妻制 还是 多夫制，都不能上升为普遍通行的方式。事实上，一夫多妻制显然是奴隶制度的产物，并且限于个别占据了特殊地位的人物(富人 和 显贵人物)。因为多妻主要是用购买女奴隶的方法取得的，而人民大众则是过着专偶制的生活。</description>
    </item>
    <item>
      <title>不原谅也没关系</title>
      <link>https://lydiacai1203.github.io/post/thinking_3/</link>
      <pubDate>Mon, 15 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/thinking_3/</guid>
      <description>Chapter1 CPTSD 指一个人在经历了长期、反复的人为创伤事件后形成的一种精神障碍（反复体验创伤内容、逃避和创伤有关的刺激物、身体过分紧张警惕、情绪失调、人际关系困难、自我负面认知）。2018 年，世界卫生组织发布了《国际疾病分类》，将 CPTSD 正式确立为一种独立的精神障碍诊断。创伤性家庭普遍存在。18 岁以上的美国人中 26% 的人被诊断出有心理障碍。&#xA;1.1 CPTSD 的主要症状 情绪闪回（最典型） 突然发生且持续时间较长的退行（退行，指人们在应激状态下，放弃已经习得的适应技巧，退回到早期的生活阶段，使用原始、幼稚的方式应对当下的焦虑，是一种不成熟的心理防御机制）。幸存者会退行至童年遭受虐待或遗弃时所产生的强烈的情绪状态。这种情绪状态可能包括 强烈的恐惧、羞耻、疏离、愤怒、悲伤、抑郁、感到渺小、年幼、脆弱、无力、无助。让人产生具有精神毁灭性的毒性羞耻感。&#xA;毒性羞耻感(情绪闪回的表象)：幸存者会觉得自己惹人厌、丑陋、愚蠢、有致命缺陷，这种强烈的感受会摧毁幸存者的自尊，触发情绪闪回，使得幸存者重新体验被父母蔑视、打击、忽视、拒绝的感受。发展为极度痛苦的自我疏离。&#xA;当童年被遗弃的经历在闪回中重现时，我们会常常孤立自己，无助地向强烈的羞耻感投降。&#xA;自杀意念 主动自杀意念：让人主动采取结束生命的行动。&#xA;被动自杀意念：患者并没有主动自杀的意图而逐渐停止。往往意味着患者闪回到了幼年时的感受，再次沉浸在强烈的被遗弃感中，以致于患者希望有人或事结束这一切。&#xA;1.2 CPTSD 的成因 通常与童年长期遭受的躯体虐待、性虐待、持续的言语虐待、情绪虐待（包括情绪忽视） 有关。&#xA;当婴儿为了寻求联结和依附而悲伤地哭喊，许多病态的父母会做出轻蔑的回应，这对于婴儿极具伤害性。因为在奴隶社会，奴隶主通常会使用蔑视来摧毁奴隶的自尊，让奴隶觉得自己没有价值、没有力量、陷入习得性无助。于是奴隶主之后只需要投入很少的精力和注意力就可以加以控制。父母对孩子发泄愤怒，在孩子心中造成恐惧，孩子心中产生羞耻感，于是很快学会抑制哭泣，不再寻求关注，再到后面完全放弃向他人寻求帮助和联结。在此后的生活中，一旦孩子想要亲近他人或尝试获取接纳收到挫败，孩子便只能忍受由被遗弃带来的惊慌绝望。&#xA;长此以往这种恐惧和羞耻感会演变为有毒的内在批判，这种内在批判会让孩子始终将父母的遗弃归咎于自己的行为，直到他们将自己变成了可怕的敌人。&#xA;1.3 更多关于创伤的信息 如果攻击或遗弃行为激发了过于强烈的战或逃反应，以致在威胁消失后这个反应还无法平息，就会造成创伤。受过创伤的人会被困在一种肾上腺素高亢的状态，其交感神经系统也持续被锁定在 “开启” 状态，使其无法激活副交感神经系统的放松功能。&#xA;如果孩子根据以往的经验知道，在受伤、害怕、需要帮助时，只能能获得父母其中一方的帮助，他就会把遭遇告诉父母。在父母的帮助下，他能通过口头宣泄、哭泣、发泄愤怒，哀悼自己暂时丧失的安全感。如果父母能采取行动确保孩子不再受伤，孩子通常能从创伤中解脱出来。他会自然地放松下来，回到副交感神经系统正常运行的状态，重新获得安全感。&#xA;如果伤害事件持续发生，孩子却没寻求帮助。或者父母没有能力保障他的安全，他就会被 “冻结” 在创伤中，出现创伤症状。如果创伤不是长期持续存在，在环境中的危险因素被有效消除的前提下，孩子只需要短期的治疗就能被治愈。&#xA;1.4 4F 反应 这些防御模式可以帮助孩子从可怕的童年中幸存下来，却也会导致他们应对生活的方式变得受限而狭窄。更糟糕的是成年以后，他们仍然被卡在这些模式中。&#xA;战(自恋型) 人面对危险突然做出了攻击性的反应。 自恋型或边缘型人格的父母，会至少选择一个孩子作为家里的替罪羊。指定替罪羊的过程就是霸凌者通过攻击弱者，卸除和外化自身的痛苦、压力、挫败感。 加害者成年后，会强势地试图塑造他爱的人，就像父母对他那样。&#xA;逃(强迫型) 人通过逃离来应对威胁，或象征性开启过度活跃的状态来逃避。 替罪羊成年后，总是会被自恋者吸引，这种心理现象被称为 强迫性重复。&#xA;僵(解离型) 人意识到抵抗无用时放弃抵抗，麻木地陷入解离或崩溃状态。 有的替罪羊成年后，会习惯性陷入解离性抑郁，并且一到社交场合就会感到极度的焦虑和排斥。 解离(一种心理防御机制，表现为在面对重大压力时产生的感觉抽离、情绪麻木、自我认同混乱、失去现实感、失忆等反应，此时的幸存者看自己感觉在看另一个人)&#xA;讨好(关系依赖型) 人在应对威胁时，是图通过讨好或协助来预先阻止和安抚攻击者。 有的替罪羊成年后，由于与生俱来的同情心与感受力，敏锐地捕捉父母心中的需求，满足他们，以使得他们平静下来，变得不那么可怕和尖酸刻薄。但这样的孩子，往往会被自恋者父母所利用，成为任自己差遣的保姆。&#xA;Chapter2 一些健康的人格特质 自我接纳 清晰的身份认同 自我同情 自我保护 从关系中获得慰藉的能力 放松的能力 充分表达自我的能力 意志力和行动力 平和的心境 自我关怀 相信生命可贵 自尊 自信 2.</description>
    </item>
    <item>
      <title>养育你内心的小孩</title>
      <link>https://lydiacai1203.github.io/post/thinking_2/</link>
      <pubDate>Fri, 03 May 2024 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/thinking_2/</guid>
      <description>Chapter1 1. 关系是由需要组成的 处理关系，就是处理需要。 由于人本身具有脆弱性和局限性，一个人的力量不足以对抗所有的问题和困难。所以人必然需要他人的支持来完善自己，需要他人的力量来为自己做一些加持，使得自己更加完整和圆满。关系的建立源于我们对他人的需求，当我们的内心判断通过关系比通过其它方式更容易实现时，我们就会自动产生建立关系的渴望。一个人不想维系关系了，则说明他对你没有去要了。&#xA;同样一种关系，每个人的需求是不同的。&#xA;同一个关系里，会有不同的需要。&#xA;关系中的需要会变化。 人一旦识别了另一个人可以满足自己的某些需要，就会无意识地渴望他满足自己更多。需求没有得到满足，就会产生矛盾。&#xA;矛盾是需要失败的结果。 矛盾，就是在关系中自己的需要没有得到满足而生发的不满。因此处理矛盾的本质，其实就是处理自己的需要。谁不满，谁处理自己的需要。&#xA;2. 需要不是爱，需要是爱的反面 需要是一种索取，爱是一种付出。 需要的意思是我希望你来满足我，需要你做一些事情来让我舒服，是你要以我为中心，想要你服务于我。而爱是我想要满足你，是我想做一些事情来让你舒服，我想以你为中心，是我想服务于你。需要是一种索取，爱是一种付出。两种完全出于不同的动力：一个是 &amp;ldquo;你要为我做&amp;rdquo;，一个是 &amp;ldquo;我想为你做&amp;rdquo;。&#xA;爱不是放纵，不是无止境顺从，不是没有原则的讨好。爱的教育是温柔坚定的。好的习惯是要去培养的，有的规则是要去遵守的。爱是在向对方传递一种善意，而需要则是在向对方传递一种敌意和控制。不必强制对方配合和认同，也不必因为对方的不配合和不认同而受伤。&#xA;需要其实并不可怕，可怕的是明明需要，却非要以爱之名来乔装。&#xA;3. 关系的稳定，来自爱与需要的平衡 长期关系的本质就是相互需要、相互支持、相互满足。关系的意义就是结盟，我的所长，补上你的所短。我的所长加上你的所长，就是一个一加一大于二的过程。我们通过彼此都变得更加强大了。&#xA;4. 关系中的三种需要状态 第一种情况：母婴式关系。 一方发出需求，另一方付出爱来满足对方需求的形式。&#xA;第二种情况：矛盾式关系。 双方都想当宝宝，都想被满足。如果不想给人当妈妈，就要有一个成年人的姿态，有基本的界限感，可以为了自己想要的自由去选择合适的拒绝方式。&#xA;第二种情况：成人式关系。 一个成年人首先具有边界感。不会委屈自己去满足对方，也不会强迫对方满足自己。要知道哪些是自己想做的，哪些是不想做的，并且能坚持自己。这样的人能把注意力放在自我身上，并且会去寻找生活的意义，然后享受生活。在这个享受的过程中，他会想和另一个人分享这种喜悦，从而和另一个人建立关系。成人式关系里，双方追求的是生活的品质。前两种还处于追求生存的阶段。&#xA;关系判断的标准是当他不回应你时，你难不难受。 如果你难受了，说明那一刻陷入了宝宝的状态。因为你希望他通过回应你来表达对你的重视，你要的就不是分享，而是重视。成人状态里的分享是，当他不感兴趣时，我会选择其它途径分享我的兴奋，而非强制他来回应我。如果你有一个基本的界限感，对方是无法消耗你的。&#xA;5. 关系中的两个难点 难点一：在母婴关系里没有人会一直愿意给你当妈妈。 一方面是对方没有这个能力一直给你当妈妈。另一方面是对方也不愿意一直给你当妈妈，因为这点连你的亲生妈妈都做不到。当妈妈没有被自己的老公照顾好时，她就会让自己的孩子来照顾她。她每一次对你不满意时，其实都是在把你当妈妈，希望从你这里获得夸奖。需要你给予关注。此刻她在扮演你的孩子。&#xA;难点二：只有你是个成年人，你才能遇到成人式的关系。 成人式的爱情是分享。前提是热爱生活，对世界保持探索欲。人不可能一直待在成人状态里，每个人都有无助的时候，一段常见的、健康的关系是在上面三种关系中动态进行着的。&#xA;6. 当你纠结要不要离开对方 关系的失衡本质事供需不平衡。解决方式就是，谁痛苦，谁离开。一个成年人为自己负责的方式之一，就是选择自己合适的关系。如果你很痛苦但不想离开，说明在这段关系中还能得到满足感，或者还有没有被满足的幻想。这时要去思考自己，到底是什么需要被满足了，了解自己的需要，才能找到方法去应对，才能做真正的取舍。&#xA;7. 直面关系本质，从需要的层面去解决关系问题 自然经营。指你并不介意你们的关系相处成什么样子，你只负责跟着自己的感觉随意地往前走，你不会去刻意地努力维护关系，也不会花费时间思考你们的关系状态。当一个人选择这种方式经营感情，存在两种情况：一、这个对你来说无所谓，有他没他都差不多，比如陌生人。二、你很信任你们之间的关系。你相信他不会离开你，为了节能会选择自然经营，比如亲人。这种情况，人在最大化做自己了，可以充分体验到关系中的轻松和自由感。&#xA;盲目经营。指你根据自己擅长的方式，并不去思考和迎合对方的需求，凭本能瞎使劲。比如为了家庭拼命操劳的主妇。这种人通常会理直气壮地陷入自己的逻辑里出不来，会觉得自己这样做是对的，就应该被看到、认可、接受、并感恩我的付出。对方如果不领情，还会觉得自己很委屈，还会抱怨对方是个坏人。这种情况，优势是能让对方感觉到自己是被在乎、被重视的，两个人的关系是连接在一起的。&#xA;理性经营。指你通过学习、思考，去看见彼此的需要，然后采用有效的方式经营关系。这种方式是反惯性的。&#xA;8. 判断需要没被满足的两个标志 当你在关系中受挫时，不要首先从对与错的角度思考，而是要有一个意识：此刻，我有一个需要没有被满足。在关系里你的情绪有多浓，你就有多需要对方。&#xA;一个人的失控行为也是需要没有被满足的标志。比如吵架、冷战、讲道理。&#xA;9. 心疼你自己 当你意识到你在关系里有需要没有被满足，你要去心疼你自己。有需求并不是错误的，而是悲伤。不要指责自己，要去思考如何安抚自己，如何用更好的方式去满足自己的需要，而非执着地指责是谁的对错。&#xA;10. 识别自己的五种需要 安全感、自由、价值感、意义感、亲密。其中亲密包括 被关注、接纳、重视、尊重、陪伴、支持 等。&#xA;10. 照顾自己的需要 第一：选择用有效的方式改变他，让他继续满足你的需要。一致性表达：真诚地告诉对方自己需要什么，而不是对方该做什么。需要保持低姿态，因为表达需求看起来和低头求人是一样的。交换：权衡利弊。示范：我可以教你如何满足我。&#xA;第二：放下对他的需要，换个有能力且有意愿的人来满足自己的需要。 没有什么需要不可以被他人替代的。如果你感觉某个需要非这个人不可，无法被替代，那是因为你还有更深的需要卡在这里，需要进一步深入地去识别。&#xA;第三：自己爱自己，满足自己的需要。一个人，如果从关系中得到的满足多一些，他就可以为自己做的少一些。如果他为自己做的多一些，那么他对关系的需要就少一些。&#xA;11. 看到对方的需要 如果你想跟对方拥有一段更和谐的关系，或者对方想要离开你，而你想挽留，最有效的方式就是去思考他的需要是什么。他的内心，有哪些需要没有得到满足？你可以为他做些什么？他又可以从你这里获得什么呢？&#xA;Chapter2 1. 安全感是什么 安全的意思就是没有危险。</description>
    </item>
    <item>
      <title>FastAPI Depend 实现原理(个人猜测&#43;粗略代码实现)</title>
      <link>https://lydiacai1203.github.io/post/fastapi_depend/</link>
      <pubDate>Sat, 15 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/fastapi_depend/</guid>
      <description>0. 依赖注入 from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create_all(bind=engine) app = FastAPI() # Dependency def get_db(): db = SessionLocal() try: yield db finally: db.close() @app.post(&amp;#34;/users/&amp;#34;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)): pass 1. 猜测原理 线索 1. 依赖注入的参数是作为参数从函数传入的，因此排除装饰器实现 2. 表现行为是 handler 开始执行前 db 被实例化好, handler 结束后 db 被 close；表现类似 contextmanager 3. 不结合装饰器 @app.post 使用，发现 db 无法倍正确实例化，而是一个 Depend 类的对象 结论 1.</description>
    </item>
    <item>
      <title>君主论 - 论市民的君主国</title>
      <link>https://lydiacai1203.github.io/post/the_prince_five/</link>
      <pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/the_prince_five/</guid>
      <description>如果一个平民，不是依靠 罪恶之道，而是由于获得本土其它市民的赞助而成为君主，这种国家称为 市民的君主国。 每个城市里都可以找到两个互相对立的党派。因为人民不愿意被贵族 统治与压迫，贵族则要求 统治与压迫人民。由于这两种相反的愿望，城市里最终会演变成以下三种结果：君主权、自主权、无政府状态。君主政体：不是由人民建立，就是由贵族建立，主要看哪方抓住了机会。当贵族发现自己统治不了人民，就开始抬高他们当中某一个人的声望。当人民察觉自己抵抗不了贵族，也会抬高他们当中某一个人的声望，扶持他成为君主，以求保护。&#xA;一个人如果依靠贵族的帮助取得君权，会比依靠人民的帮助获得的君权更难于保持。因为君主会发现自己周围有许多人自以为同他是平等的，所以他也不能按照自己的意思随意指挥或者管理他们。一个人如果依靠人民的赞助取得君权，他会发现自己是巍然独立的人，在自己周围没有人不服从自己，有也只是极少数。除此之外，如果君主能公平地处理事情而不损害他人，虽然不能满足贵族的欲望，但却能让人民满足。人民的目的比贵族的目的来的公正，毕竟前者只是不想被压迫而已。&#xA;人民数量多于贵族，因此如果人民感怀不满，君主是永远也得不到安全的。虽然如此，但人民所能做的最坏的事情可以预料，左不过就是抛弃自己。而贵族的眼光更加敏锐深远，常常能避免于难，因此贵族对君主的抛弃和反对更加可怕。没有上述贵族，君主可以过的更好，因为他可以随时设立或者废黜贵族，并且能够随心所欲地给予或者抹掉他们的名声。&#xA;统治贵族应该：对于约束自己行为且不贪婪的贵族，应该给予光荣和爱护。对胆怯或天生缺乏勇气的贵族，应该利用他们，尤其是那些能给你提出有益意见的。如此当你隆盛的时候，他们会尊敬你；当你处于逆境的时候，也无需畏惧他们。对于属于其它情况的贵族，要让他们依靠你，没有你不行。其中故意不依靠你是一种征象，意味着他们为自己着想比替你想的跟多。君主要防范这类人，把他们当作公开的敌人那样警惕，在对君主不利的时期，总是这群人出来灭掉君主。&#xA;统治人民应该：同人民保持友好关系，只要做到不压迫人民就能达到目的。&#xA;如果君主是由于贵族的帮助取得君权，成为君主后头一件事情就是争取人民，如上所述，只需将人民置于自己的保护之下即可，人民本以为会被压迫，现在却得到好处，一定会对自己的恩人更加接近。总之君主一定要和人民保持友谊，否则在逆境之中就无补救方法。&#xA;以上论述只适用于君主，而非平民。如果一个平民把自己的基础建立在人民之上，并且深信自己收到敌人或者官吏压迫时，人民会解救自己，那么他注定失望。&#xA;最后，英民的君主应考虑的是使他的市民无论处于哪一个时期（太平时期 &amp;amp;&amp;amp; 危难时期）对于国家或事他个人，都有所需求，他们就会对你永远效忠了。&#xA;最后的最后，俺来总结： 依靠群众取得的政权比依靠贵族取得的政权来的稳固 a. 人民数量大，起义不好控制 b. 人民要求低，很容易满足和被控制 c. 获得政权以后消灭贵族 d. 无法消灭贵族就要使得贵族的利益与自己的决定牢牢相关 e. 嘉奖重用那些听话的贵族做表率 f. 不要相信和平时期的承诺 公司里顶层人员的调动往往会带动所在部门领导的流动。我遇到过那种抢夺属下 KPI 的领导，遇到过因为临危受命而来却因权利更迭被抛弃而全心全意保护下属的领导。人总是在利益不相关的情况下选择冷眼旁观，因此更要提防对你热心友好的人，背后的目的是什么。是希望得到下属拥戴巩固权力的领导，还是希望得到同事好评的即将晋升的同事。这个世界没有对错，只有立场。当别人反对你时，不代表你的观点你的成果不好，可能仅仅是因为他也有一样的观点或成果要推出，为了争抢那点 KPI 和在领导心里的地位，总是要不顾一切打击利益负相关的人。不要盲目地否认自己，当然也不要盲目自信。 </description>
    </item>
    <item>
      <title>君主论 - 论以邪恶之道获得君权的人们</title>
      <link>https://lydiacai1203.github.io/post/the_prince_four/</link>
      <pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/the_prince_four/</guid>
      <description>1. 希腊西西里国王 - 阿加托克雷 阿加托克雷 是一个陶工的儿子，从小就坏，后来他投身军队，经过努力成为 锡拉库萨 的地方执政官。但他的野心不仅如此，而是想当上 锡拉库萨 国王。上位是设计召集 锡拉库萨 人民和元老院，假意商讨共和国国事，实际是为了斩杀他们。他的士兵杀掉了元老院和最富有的一群人，使他成功成为锡拉库萨的国王。阿加托克雷延续了叙拉古统治者与迦太基人争夺 西西里 主导的政策，他引诱迦太基人攻打锡拉库萨，自己则带领一批兵马攻打 非洲。使得迦太基人陷入窘境，被迫同阿加托克雷讲和，迦太基人占领非洲就足够了，把西西里让给了阿加托克雷。&#xA;2. 费莫尔 - 奥里维罗托 奥里维罗托 从小由舅舅抚养，后被送至 保罗·维泰利 手下当兵，保罗死后又去了保罗弟弟 维泰洛佐 手下当兵，由于他的机智和身强胆壮，他很快成为军中第一人。但他的野心，使他不敢屈居于人。于是他写了一封信给自己的舅舅，声称想回故乡看看祖产，并且由于自己对荣誉的看重，想随行一百名骑兵同去。他请求舅舅安排一切。舅舅非常高兴且尽心地安排好一切，并接 奥里维罗托 入住自己家。随后 奥里维罗托 举办了场宴会，邀请了舅舅和一些重要人物，并设计把他们骗入房中杀害。随后 奥里维罗托 又把宫廷里的最高长官围困住，迫使他们承认他是国王。他把那些对他心怀不满可能加害于他的人全都杀了。&#xA;3. 总结 有些人奸诈残暴，却能长治久安地治理自己的国家，人民也不反抗，敌人也不敢入侵。有些人奸诈残暴却在和平时期都不能保有自己的国家。这是由于前者 妥当 地使用残暴手段。后者 恶劣 地使用残暴手段使然。&#xA;妥善： 为了自己安全的必要，可以偶然地使用残暴手段。除非残暴的手段可以为自己的臣民谋得福利，并且此后都坚决不再使用。&#xA;恶劣： 尽管开始使用残暴的手段是寥寥可数的，可是其后与时俱增。&#xA;由此可见，占领者在夺取一个国家的时候，应该审度自己必须从事的一切损害行为，并且要立即毕其功于一役，使自己日后不必日复一日地搞下去。这样一来，由于不需要一再地从事侵害行为，他能够重新使得人民感到安全，并且通过施恩布惠把他们争取过来。反之，如果一个人由于怯懦不这样做，他的手里就必须时时刻刻拿着武器，他也永远无法信赖自己的百姓，人民会由于他的不断损害感到不安全。因此 损害应该一下子干完，人民的积怨就会少一些。恩惠应该一点点给予，以便人民更好地品尝恩惠的滋味。此外，轻易不能更改关于从事损害行为和施恩布惠的政策，因为此时即使做好事也无法挽回，人们只会认为你是被迫如此。而不会对你产生任何感谢。</description>
    </item>
    <item>
      <title>君主论 - 论依靠他人的武力或者由于幸运而取得得新君主国</title>
      <link>https://lydiacai1203.github.io/post/the_prince_three/</link>
      <pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/the_prince_three/</guid>
      <description>如果一个人认为，为了确保他的新的王国领土安全免遭敌人的侵害，有必要争取朋友，依靠武力或者讹诈制胜，使得人民对自己又爱戴又畏惧，使用军队既服从又尊敬自己，把那些能够或者可能加害自己的人们消灭掉。采用新的方法把旧制度加以革新，既有严峻的一面使人感恩，要宽宏大量且慷慨好施，要摧毁不忠诚的军队，创建新的军队，要同各国国王和君主们保持友好，使他们不得不殷勤地帮助自己，或者是诚惶诚恐不敢得罪自己。&#xA;如果任何人相信给以新的恩惠就会使一个大人物忘却旧日的损害，他就是欺骗自己。因为人们会处于恐惧或者仇恨来损害你。这让我想起知乎上的一个回答，如何让一个心智俱全的人忘记往日受到的伤害。</description>
    </item>
    <item>
      <title>不能完全相信大脑</title>
      <link>https://lydiacai1203.github.io/post/thinking_1/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/thinking_1/</guid>
      <description>一直以来，我都经常会为自己的很多行为感到不解。比如，为什么那么在乎别人是否正确明白自己想表达的意思。这种固执让我不轻易在言语上认输，我为此一直感到苦恼。&#xA;早些时候我一直将此归咎于自己不幸的童年。大约是两年前，看了一本书，出于实践目的，我开始套用书上公式，将一些行为与我的童年挂钩，不幸地是，皆找到合理的解释将星星点点的事物联系在了一起。我开始把 我的固执 与 童年时期的思考经常得到父母的否定 联系在一起。现在想来，父母只是这个习惯的催化剂。&#xA;美国 大卫.萨迪沃 的《反套路》为我这种行为作出的解释是:&#xA;1. 渴望确定性 我们的大脑喜欢 正确、持续、稳定 的东西。我们需要知道 &amp;ldquo;自己是对的&amp;rdquo;。事实上，我们需要 感觉自己是对的。这就是人类的天性与后天形成的认知偏差让我们相信自己永远是对的。当我们觉得某个决策，某种信念是正确的。无论它是大小，大脑都会感到快乐，因为大脑喜欢处于快乐的状态，所以我们喜欢 &amp;ldquo;感觉自己是对的&amp;rdquo;，但 &amp;ldquo;感觉是对的&amp;rdquo; 意味这 &amp;ldquo;可能是不对的&amp;rdquo;，因此这种 &amp;ldquo;感觉是对的&amp;rdquo; 往往会被我们当成 &amp;ldquo;这就是对的&amp;rdquo;。&#xA;2. 证实性偏差 人们寻找能证明自己观点的证据，忽略不能证明自己观点的证据，这就是 证实性偏差。于 睡觉、性爱、烧烤 一样，这就是人类的天性。许多人在接触到反认知的东西时，会感到愤怒，他会急于寻找新证据，但是目的并非是理性地评估新发现的信息，说服自己改变立场，而是先寻找能证明现有立场的信息，因为他们压根就不可能改变立场。当承认事实要付出高昂的代价时，无论证据是多么地确凿，都会遭人质疑。这种的代价可能是 “都灵裹尸布” 里的宗教信仰冲突。但是更多的是与 &amp;ldquo;个人信誉&amp;rdquo; 冲突，即个人的 &amp;ldquo;对错&amp;rdquo;。&#xA;我向来认为自己是个坚定的唯物主义者，我相信科学，相信世界上的一切都有联系，相信人的一切行为都有原因。我看书的目的就是为了找到答案，这个答案不光光是 &amp;ldquo;质量足够大的物体可以扭曲空间&amp;rdquo;&amp;hellip; 更重要的是，我想知道为什么，我会做出一些自己难以理解的事情，或产生一些难以控制的情绪。最严重的事情就是，为什么我会如此执着于输出自己的想法并渴望得到别人的认可。我不希望这个答案是我父母给出的：你这个人太敏感，心思太重，想太多。现在我得到了另一个答案，这个答案是一位写出了 霸榜 30 年的畅销书的作者给出的，连他也说，这个是人类的天性，是进化演变而来的习性，没有这个习性的话，人类早就灭绝了。正因为遇到不确定或超出认知范围的东西会给我们的大脑带来警告，所以我们才得以规避这些风险。&#xA;可是，大脑给的信号，并不总是对的。偏见，有时连自己都意识不到。我又为什么这么相信自己的大脑？它越是要控制我的情绪，我越是要反着做。和同事对一件事有不同的意见，他坚定地反驳我，认为自己做的没问题，我虽不认同，但我也偏要笑着回复 &amp;ldquo;ok&amp;rdquo;。这不再是自我保护机制（告诉自己，一切与我无关，我只是个打工人）。而是，我要摆脱大脑对我的情绪控制，想让我争执，让我难受，我偏不。我就是要逆天性改情绪做自己。&#xA;最后，感谢这本书，让我绝望的同时，也让我找到了学习知识的另一个意义，那就是，让自己的心灵自由。</description>
    </item>
    <item>
      <title>君主论 - 不要中立</title>
      <link>https://lydiacai1203.github.io/post/the_prince_two/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/the_prince_two/</guid>
      <description>1. 中立的缺点&#xA;背景，法国路易十二扬言要从瑞士手中夺回米兰。马基雅维利认为意大利教皇应当支持法国而非保持中立。&#xA;1. 中立会让人觉得你优柔寡断，形式越急迫，越应当果断决断 2. 中立将自己置于两方都讨厌的境地，因为赢家不想要犹豫的朋友（在困难之际不愿意援助自己）而输家也不想要成为援助者（因为在你有能力帮助他的时候拒绝了他）。马基雅维利认为即使失败了，人们也会认为你有坚定的立场。 3. 优柔寡断会被认为是温和的不足以令人畏惧的对手。而一位君主在成为真正的队友或敌人时也会更受人尊敬。 （这是不是说明，只有实力足够强，才有资格保持中庸） 2. 什么时候选择中立&#xA;只有推迟决定对己方有战略性的优势时才可以采用&#xA;3. 决断的基本原则&#xA;马基雅维利认为，在处理自己的基本事务时，应当避免选择实力远比你强大的一方为友，因为如果他们赢了，你就是他们夺权的障碍。&#xA;3. 中立的思考&#xA;应当区分 缺乏勇气而保持中立 与 因慎重而远离事端 的区别。&#xA;在二战期间，两位法西斯独裁者，意大利的墨索里尼选择了希特勒，而西班牙的弗朗哥选择了保持中立，前者最后失败战争并丢失性命，后者则延续了自己的统治。万事万物都是很复杂的。战败国往往需要承担巨大的后果。</description>
    </item>
    <item>
      <title>君主论 - 爱戴还是畏惧</title>
      <link>https://lydiacai1203.github.io/post/the_prince_one/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/the_prince_one/</guid>
      <description>1. 古罗马将军 - 大西庇阿&#xA;被尊重 &amp;amp;&amp;amp; 不被畏惧&#xA;原因：他没有采取一些 有损于 自己名誉的军事或政治策略&#xA;后果：在西班牙，由于军机涣散发生叛变&#xA;环境背景：当时罗马人们认为善良慷慨，施以同情时高贵的品质而非不当的行为&#xA;作者点评：君主不应当介意为了子民的和平和忠诚而被称为残酷的人&#xA;2. 迦太基名将 - 汉尼拔&#xA;被尊重 &amp;amp;&amp;amp; 被畏惧&#xA;原因：异国作战 &amp;amp;&amp;amp; 军队种族复杂 &amp;amp;&amp;amp; 军队庞大&#xA;结果：没有针对他个人的叛变发生&#xA;作者点评：因为他的惨无人道和过人英勇，在士兵眼中他是一个所向披靡且可怕的人。如果没有残酷，其他的品质也难成气候&#xA;总结1 - 畏惧 优于 憎恶：&#xA;作为领袖和老板，只有勇气和擅长自己的工作，并不足以保证员工的忠诚。强权和纪律可以保证他们在自己的控制之下。好领导受人爱戴，而有实力的领导受人尊敬和拜服。&#xA;(Good leaders are admired, strong leaders are respected.)&#xA;太富有同情心会导致不安和混乱。残酷是另一种仁慈，汉尼拔残酷地将自己的人民从更可怕的政治暴乱中解救出来，这就不算残酷。仁慈可能会滋长暴乱和无序，最终伤及无辜。毕竟极限的刑法影响的只是少数人。&#xA;如果做不到两者兼具，那么 畏惧 优于 爱戴。因为恶是大部分人的本性，他们不懂得感恩且善变，既虚伪懦弱又贪得无厌。友谊是靠收买得来的，而不是靠美好的品行和高尚的思想。当危险来临时，侵害受爱戴的人的成本会比侵害受畏惧的人的成本低。因为爱戴会在人们自身利益受损时消失，而畏惧会被一系列残酷惩罚所加强，因而会一直有效。&#xA;总结2 - 被畏惧而不被憎恶:&#xA;马基雅维利发现，当君主不伤害子民的姓名和土地时，人们更倾向于顺从。当君主不得不加强纪律而侵害子民的性命时，惩罚的原因和公正性必须明确。因此应当只在必要时残酷。作者不建议剥夺人的财产，因为他认为，比起剥夺人的财产，原谅杀害自己的爱人会更快一些。&#xA;总结3 - 不能依赖人们爱戴的原因:&#xA;马基雅维利认为大部分人是自私的只为自身考虑的，他们只会支持为自己带来好处的君主。&#xA;最弱者依靠爱戴，而强者会使人民产生畏惧。最强者会在人民心中植入恐惧和爱戴，至少不是憎恶。因此君主以强制和决断为行动指导这一点很重要。</description>
    </item>
    <item>
      <title>安全开发指南（持续更新）</title>
      <link>https://lydiacai1203.github.io/post/sec_guide/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/sec_guide/</guid>
      <description>开发规范&#xA;腾讯 Python 安全指南&#xA;1. 代码实现 1. 避免使用不安全的对称加密算法（避免 DES/3DES，建议 AES） 2. 确保重要行为都记录在日志上，且可靠保存 6 个月以上 3. 禁止将未经验证的用户输入直接记录日志（防止注入漏洞：恶意用户插入伪造的日志数据，从而让系统管理员以为是系统行为） 4. 避免在日志中保存敏感信息（明文密码、密文密码 等等） 2. 系统口令 1. 禁止使用 空口令、弱口令、已泄漏口令 2. 口令强度需满足 + 密码长度大于 14 位 + 包含：大小写英文字母、数字、特殊字符 + 不得使用默认的初始密码 + 不能与最近 6 次使用过的密码重复 + 不得与其它外部系统使用相同的密码 3. 口令存储安全 + 禁止明文存储口令 + 禁止使用弱密码学算法加密存储口令 + 使用 不可逆算法 和 随机 salt 对口令进行加密存储 + 禁止传递明文口令 + 禁止在不安全的信道中传输口令 3. 配置 / 环境 1. 建议使用 Python 3.6+ 版本，因为 Python3 在 2020 年就停止维护了，相关漏洞不能得到及时修复和维护 2.</description>
    </item>
    <item>
      <title>Python 原生 SQL 如何预防 SQL 注入</title>
      <link>https://lydiacai1203.github.io/post/raw_sql_q/</link>
      <pubDate>Fri, 08 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/raw_sql_q/</guid>
      <description>什么是 SQL 注入 腾讯云博客 SQL 注入攻击是一种常见的Web攻击方法，攻击者通过把 SQL 命令注入到 Web 后台数据库的查询字符串中，最终达到欺骗服务器执行恶意 SQL 命令的目的。例如可以从数据库获取敏感信息，或者利用数据库的特性执行添加用户、导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。 2. SQL 注入例子 SQL 注入只会发生在字符串拼接的例子中，常见的攻击有拖库、拖表、篡改网页内容、收集数据库信息为其它攻击做准备等等。&#xA;假设代码中是这样一段代码 username = input(&amp;ldquo;enter in username&amp;rdquo;) sql = f&amp;quot;&amp;quot;&amp;quot; select * from content where create_user = &amp;ldquo;{username}&amp;rdquo; &amp;quot;&amp;quot;&amp;quot;&#xA;用户输入 username = &amp;rsquo;testc&amp;quot; or 1 = &amp;ldquo;1&amp;rsquo;, SQL 就会变成 sql = f&amp;rdquo;&amp;quot;&amp;quot; select * from content where create_user = &amp;ldquo;testc&amp;rdquo; or 1 = &amp;ldquo;1&amp;rdquo; &amp;quot;&amp;quot;&amp;quot; 3. SQL 注入预防通用方法&#xA;外部参数动态拼接 [&amp;quot;\&amp;quot;&amp;quot;, &amp;quot;\\&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;&#39;&amp;quot;, &amp;quot;=&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;#&amp;quot;, &amp;quot;;&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;&amp;amp;&amp;quot;, &amp;quot;$&amp;quot;, &amp;quot;(&amp;quot;, &amp;quot;)&amp;quot;, &amp;quot;%&amp;quot;, &amp;quot;@&amp;quot;, &amp;quot;,&amp;quot;] 过滤特殊符号 遇到固定格式的变量，在 SQL 执行前严格按照固定格式检查 特殊符号转义使用（SQL 中的转义字符是单引号） 参数化查询 绑定变量使用预编译语句（预防 SQL 注入的最佳方式） ORM 使用 ORM 避免 SQL 注入 存储 敏感信息加密存储 将 username = &amp;rsquo;testc&amp;quot; or 1 = &amp;ldquo;1&amp;rsquo; 中的特殊符号转译，除了左右两侧的单引号 这样 &amp;ldquo;testc&amp;rsquo;&amp;rdquo; or 1 = &amp;lsquo;&amp;ldquo;1&amp;rdquo; 就变成了一个值，而非表达式的一部分 sql = f&amp;rdquo;&amp;quot;&amp;quot; select * from content where create_user = &amp;ldquo;testc&amp;rsquo;&amp;rdquo; or 1 = &amp;lsquo;&amp;ldquo;1&amp;rdquo; &amp;quot;&amp;quot;&amp;quot; 4.</description>
    </item>
    <item>
      <title>骚渣一体 --《圆月弯刀》</title>
      <link>https://lydiacai1203.github.io/post/movie_szyt/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/movie_szyt/</guid>
      <description>老实说是冲 古天乐 和 梁小冰 的脸才去看的。看之前没想到味儿会这么冲。&#xA;看完这部电视剧我又去看了小说（不过没看完）。我想到以前还看过古龙的《陆小凤传奇》，貌似不是这么个味道啊。看的时候甚至一度让我以为古龙写这部小说的时候得了痔疮。直到后来去请教度娘，才知道古龙只写了 1/10，剩下的都是 司马紫烟 代笔的。淦，浪费我的感情。&#xA;电视剧改编了很多。讲的是男主丁鹏从小就特别崇拜在镖局打工的爸爸，觉得自己老爸的武功天下第一，谁知道有一次和小伙伴出去玩，半路正好遇到老爹在押镖，好家伙，说时迟那时快来了几个强盗，老爹啪一下就给跪了，不光跪了还尿了。小伙伴都笑话丁鹏。小丁鹏又羞又气回家了，从此以后拿着他爹捡来的 天外流星 的剑谱，在深山里刻苦练习。&#xA;要知道武侠小说里的男主要想出人头地，必须先父母双亡。丁鹏老爹坟头草都三米高的时候，丁鹏的 天外流星 也练的出神入化了。他决心要 出 人 投 地！于是就出山了，挑战这个挑战那个，都赢了。到了挑战万松山庄的 柳若松，谁知道这人是个阴险小人，派出自己的妻子秦可情去勾引丁鹏，用那一夜换取了那一页。柳若松得到天外流星的剑谱以后，破解了剑谱，打败了丁鹏。并说天外流星是自己自创的剑法，是丁鹏抄袭了。丁鹏百口莫辩，被逼的跳下了海。流落到了小岛，遇见了魔教公主，青青。两人互生情愫，丁鹏不仅入赘，还学习了魔教刀法 圆月弯刀，于是带着青青回中原找柳若松报仇。&#xA;再说秦可情和柳若松越过越憋屈，越过越觉得丁鹏才是真男人。于是当她再次见到丁鹏，她马上投怀送抱，答应里应外合，协助丁鹏复仇，把六大门派的武功心法秘籍全都刻到柳若松的密室里面。那边青青化身为蓝蓝，接近柳若松。让他四处杀人，然后教了他一套小学生剑法，骗其一定能打败丁鹏。最后？最后柳若松被废全身武功，当乞丐去了。&#xA;丁鹏心里一直想要雄霸天下，想要打败 剑神谢晓峰，成为天下第一。他把 姬无命 关了起来，假装自己是一直写诗给 谢小玉，勾搭上了谢小玉，继承了谢晓峰的武功，成为了神剑山庄的庄主。青青这边为了化解姬无命和丁鹏的矛盾，被柳若松害得瞎了眼睛。等她再见到丁鹏，已经是在丁鹏和谢小玉的婚礼上了。圣母心泛滥的女主当然是选择成全丁鹏啦。&#xA;丁鹏顺理成章成为武林盟主以后，青青老爸魔教教主出现了，一系列套路把丁鹏的命门捏得死死的，上演了一出无间道。鹏鹏子失去了一切，不干了，他发现自己心里唯爱青青，于是又去找青青。两人开了一个客栈，叫无命客栈，从此过上了隐居的生活。&#xA;本来写到这里真的可以了，但是魔教教主的结局还没写呀。说青青他爹来找丁鹏，让他交出弯刀。青青直到两人必有一死，于是易容成自己老爹去找丁鹏，被丁鹏干死了。丁鹏一看是自己老婆，不行啊，气的和他爹干了一架，俩人一起失踪了。留下一个儿子，丢给姬无命抚养。&#xA;写在最后，看完这部剧我最大的收获就是，原来 平平无奇的梗 是出自这部剧。之前我还一直以为是神雕侠侣里的。如果不是馋古天乐的颜，真的很不建议看，除非你想洗眼睛。</description>
    </item>
    <item>
      <title>Linux lsof 命令使用</title>
      <link>https://lydiacai1203.github.io/post/linux_lsof_usage/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/linux_lsof_usage/</guid>
      <description>为了以后查阅方便所做。 ------- 菜大头 lsof 简介 `lsof` 是 `list open files` 的简称。意思是 列出系统中打开的文件。由于 Linux 中 `everything is file`。所有的对象都可以看作是文件，`lsof` 就可以知道用户和进程都操作了哪些文件，也可以查看系统中网络的使用情况、设备信息。 lsof | head -n 20 会列出系统中所有打开的前20个文件，每个文件一行 FD cwd: 当前工作目录 txt: 应用文本(代码、数据) mem: 内存映射文件 mmap: 内存映射设备 TYPE REG: 普通文件 DIR: 文件夹 lsof -p 1190 打开 1190 进程打开的所有文件 lsof -u caiqingjing or lsof -u ^caiqingjing 打开某个用户打开的文件 or 除了某个用户.. lsof file_path 查看某个 文件/目录 被哪些进程打开 lsof +d dir_path 列出访问某个目录的所有进程 lsof -c nginx 列出某个命令使用的文件信息 使用 lsof 查看网络信息 lsof -i 列出所有的网络连接信息 lsof -i TCP -i 后面跟协议类型，只显示 TCP 网络协议的连接信息 lsof -i :80 查看 80 端口被哪个进程使用 lsof -i @172.</description>
    </item>
    <item>
      <title>Linux 内存管理</title>
      <link>https://lydiacai1203.github.io/post/linux_memory_manage/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/linux_memory_manage/</guid>
      <description>free usage (venv367) caiqingjing@ip-127.0.0.1:~$ free -h 总计 已用 空闲 共享 缓冲/缓存 可用 内存： 31G 7.1G 2.7G 105M 21G 23G交换： 0B 0B 0B 1. 关注 可用 列，估计有多少内存可用于启动新的程序而无须交换。 2. 理论上，used - buffers/cache 表示应用程序实际使用的内存？；free+buffers/cache 表示理论上可以被使用的内存。free 仅仅表示未被使用的内存大小。仅仅看 free 来判断是不够准确的。 3. 当可用内存接近 0 或 非常小时，已用内存接近总容量 时，意味这需要使用到交换磁盘了。可以使用 `grep -i kill /var/log/messages *` 或 `dmesg | grep oom-killer` 检查内存溢出日志消息。 缓存（cache） read_cache:读文件时，通常需要将硬盘里的数据读入内存，但是硬盘和内存的读取速度相差太多，因此 linux 会将数据读入 cache 中，然后从 cache 中读取需要的数据。当一个缓存中的数据被多次读取，实际上就减少了该数据从慢速设备中读取的次数。因此 cache 中的数据是随机访问的特性。write_cache:与 read_cache 对应，它的目标应该是减少写入慢速设备的次数。使用 cache 的话，可以多次写入 cache, 但是只写入一次硬盘。 缓冲（buffer） read_buffer: 每当 buffer 满或者主动 `flush` 时会触发一次读取，对于小数据可以减少读取次数，对于大数据可以控制单次读取的数据量。通常来说，先入 buffer 的数据会被先读取，所有的 buffer 数据几乎一定会被读取，拥有顺序访问的特性。write_buffer:同上，也是需要 buffer 满或者主动 `flush` 时才会触发写入。如果每次写入的数据量相对固定。因为如果一次写入 4k 对与某个设备来说效率最高的话，buffer 一定是 4k。小数据积攒到 4k 写入，大数据分割成 4k 的碎片写入，这是 write_buffer 的用处。 交换内存（swapping） 当主存(RAM) 不足以临时存储多个程序时，我们从 RAM 中取出一些程序，通过 swap out 的机制将它们存储到硬盘中。当 RAM 可用时，我们再次将程序从硬盘交换到 RAM, 这就是 swap in。Linux 中的交换空间是物理内存的两倍。优点： 1.</description>
    </item>
    <item>
      <title>断点续传的原理</title>
      <link>https://lydiacai1203.github.io/post/download_file/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/download_file/</guid>
      <description>参考文档&#xA;1. 什么是断点续传？ 可以让用户从上一次下载中断的位置接着下载的机制。 2. 断点续传的原理 1. `curl -I {url}` 查看响应头部是否有 `content-range` 字样，有则代表服务端支持断点续传功能。 2. HTTP HEADERS 1.1 Range(在有 If-Range 的时候才会生效) * Range: bytes=0-1023 请求资源的前 1024 个字节 * Range: bytes=-1023 请求资源的倒数 1023 个字节 * Range: bytes=1023- 请求资源第 1024 字节开始及以后的资源 * Range: bytes=0-50, 100-150 请求资源的多个部分 1.2 If-Range(必传两个中的一个，但不能同时传) 1.2.1 Etag * 675af34563dc-tr34 * 文件资源的唯一标示，一个字符串 1.2.2 Last-Modified * If-Range: Wed, 21 Oct 2015 07:28:00 GMT * 上一次文件资源修改时间 3. RESP HTTP STATUS CODE 3.1 206 - Partial Content（此次请求成功） 3.</description>
    </item>
    <item>
      <title>Elasticsearch2.x 权威文档 （摘抄）</title>
      <link>https://lydiacai1203.github.io/post/es_doc_readingnote/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/es_doc_readingnote/</guid>
      <description>Elasticsearch2.x 权威文档 （摘抄） 很多用法都已经过时，看完这个我打算再看一下 7.x。仅作为快速查阅的工具文档使用，可能不会和原文一致。希望尽量做到精简。 有一些模块因为暂时使用不到所以选择不看，毕竟没有应用的情况下是很容易忘记的。&#xA;1. 面向文档 Elasticsearch 是 面向文档 的，意味着它存储整个对象或文档，Elasticsearch 不仅存储文档，而且 索引 每个文档的内容，使之可以被检索。在 Elasticsearch 中，我们对文档(而不是对行列数据)进行索引、检索、排序、过滤，这也是 Elasticsearch 能支持复杂全文检索的原因。&#xA;2. JSON Elasticsearch 使用 JavaScript Object Notation (JSON) 作为文档的序列化格式。具体可以看 serialization 和 marshalling 两个处理模块。&#xA;3. 几个名词 索引 .n 一个索引类似于一个数据库，是一个存储文档的地方。 索引 .v 索引一个文档就是存储一个文档到一个索引中以便于被检索或是被查询。类似于 insert, 当文档已存在时(_id已有) 会进行更新。 倒排索引 倒排索引被作用在文档上，以便于提升数据的检索速度。默认的，文档中的每一列都有倒排索引，没有倒排索引的属性是不可能被搜索到的。 4. 检索文档 GET - /index/mapping/id 即可检索出 ID 对应的对象&#xA;GET - /index/mapping/_search 用于检索所有的对象(一个搜索默认返回十条结果, 放在 hits 中)&#xA;GET - /index/mapping/_search?q=alst_name:Smith – URL 查询参数查询&#xA;GET - /index/mapping/_search – 进行查询表达式搜索(部分匹配)</description>
    </item>
    <item>
      <title>GIT 常用命令查阅手册</title>
      <link>https://lydiacai1203.github.io/post/git_command/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/git_command/</guid>
      <description>练习平台 - 强烈建议新手通关&#xA;git commit 将当前版本和仓库的上一版本进行对比，将所有的差异打包到一起作为一个提交记录。 git branch &amp;lt;branch_name&amp;gt; 创建分支 git merge &amp;lt;branch_name&amp;gt; git rebase master 将 bugFix 里面的 commit 按照顺序复制到 master 下。也就是说 bugFix 在 master 分支的最顶端了。 git checkout master git rebase bugFix # 相当于将 master 的 commit 复制到 fixBug 下，master 会在 bugFix 的顶端，所以 master 只会往下移一格。 HEAD 总是指向当前分支上最近一次的提交记录。 HEAD 通常情况下指向分支名的。 也就是说 master 分支其实是 master 指针，head 指针是单独的 head 指针。 `git checkout &amp;lt;commit-sha&amp;gt;` 便可以移动 head 指针。 cat .git/HEAD git symbolic-ref HEAD 这两句可以查看当前的 HEAD 指针指向 ^ 相对引用，n 个 ^ 或者 ~n 就是向上 n 个 commit git checkout master^ 或者 git checkout HEAD~4 git branch -f master HEAD~3 强制修改分支位置，将 master 分支强制指向 HEAD 的第三个父级提交。 git reset HEAD~1 通过分支记录回退几个提交记录来实现撤销改动。 git revert HEAD 通过在要撤销的提交记录后面新增一个提交，然后在新提交里面引入一些更改，这些更改便是用于撤销记录的。 git cherry-pick 将一些提交复制到 HEAD 下。 交互式的 rebase 如果你不知道要提交的 sha 值，就可以使用交互式的 rebase.</description>
    </item>
    <item>
      <title>两种权限系统，主要是吐槽设计</title>
      <link>https://lydiacai1203.github.io/post/record_of_a_destroy/</link>
      <pubDate>Wed, 01 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/record_of_a_destroy/</guid>
      <description>过年那段时间真的太难受了。这期间遭受了很多事情。 但是我现在记不住太多东西了。朋友圈里多了很多人，三家公司，三家公司的同事。我不能和以前一样在里面抱怨什么了。赖哥的骚操作积累的太多，我都写不完。&#xA;安全运营平台当时设计权限系统的时候，权限上分了两部分，一个是功能权限，一个是数据权限。功能权限控制是否能访问接口，数据权限控制返回的数据，不具有完全的数据权限的只会返回部分数据。考虑到用户配置的方便性，还有工时等限制，最后采用了参数控制的方式。这样说不是很直观，下面简单说明一下权限表的设计。&#xA;id perm_name perm_key perm_args created updated status 1 地址标签库 - 黑地址标签 - 读 black_address_tags_read category=1, 2, 3&amp;amp;status=1 2020-01-01 00:00:00 2020-01-01 00:00:00 1 id role_name created updated status 1 super_user 2020-01-01 00:00:00 2020-01-01 00:00:00 1 id role_id perm_id created updated status 1 1 1 2020-01-01 00:00:00 2020-01-01 00:00:00 1 id user_name created updated 1 caiqingjing 2020-01-01 00:00:00 2020-01-01 00:00:00 id user_id role_id created updated 1 1 1 2020-01-01 00:00:00 2020-01-01 00:00:00 id user_id perm_id created updated 1 1 2 2020-01-01 00:00:00 2020-01-01 00:00:00 应用场景：</description>
    </item>
    <item>
      <title>Study Tips(2019&#43;2020)</title>
      <link>https://lydiacai1203.github.io/post/study_tips_2019/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/study_tips_2019/</guid>
      <description>1.10:57 完成了人生中第一次服务器购买以及成功地翻出了墙.&#xA;2.解决了一个关于使用gunicorn打印不出日志的问题&#xA;3.破解了银保监的反爬，学到很多东西&#xA;4.将html转成pdf的简便方法，用chrome打开html，ctrl+p就可以转化成pdf了&#xA;5.mongodb创建联合索引create_index([(field, 1), (field2, -1)])&#xA;6.原来除了有os.system()直接执行command,还有os.popen()，原理是创建一个管道，然后可以这个管道里标准输出流里的东西拿出来，拿到return的对象，fp.read()即可，用完fp.close()&#xA;7.遇到了一个坑，使用phantomjs的时候，比较慢，所以我希望这玩意只有一个，就弄成了全局变量，结果，发现driver.quit()失效了，根本没关闭上，这就很恶心人了。 解决方法是弄成局部变量&#xA;8.假如问你：cookie和session的区别 你知道怎么回答吗 反正我是重新认识了cookie,而且最让我惊讶的是，问了好多同事，给我的回答竟然都是和我面试的时候是一样的回答。我有时候不禁会想，面试官在问我这个问题之前，自己是否也清楚cookie和session的区别呢&amp;hellip;..又放肆了，还是好好学习吧&#xA;9.markdown里面如果想使用空行的话，可以使用html里面的br标签，但是要在br标签的前后都给到一个空行，在github上面显示才比较好看。或者使用空格+空格+换行，也可以达到一样的效果&#xA;10.mysql5.6 的 最左前缀优先 和 mysql5.7 的 最左前缀优先不一样，比如说现在有一个联合索引(name, cid), 有一条查询语句：select * from tablename where cid=1;这条语句在5.6中就不会走索引，但是在5.7中会走索引&#xA;11.今天知道一个新的markdown语法，[TOC] 可以自动按照生成目录，但是github不支持&#xA;12.set里面允许放的是不可变对象, 什么是不可变对象(string, numbers, boolean), 同理dict的key也是。这个fluent-py里面有讲解。加入我现在有两堆对象，我想做一个交集。但是我不想用for循环一个一个去比对。这个对象的数据成员都是由基本类型组成的。对象显然是放不进set里面的，这时候只需要实现__hash__和__eq__，具体解释就不在这里写了，但是，但是，但是，你想要去比对，肯定是和__eq__有关系，所以在实现__eq__的时候，势必要结合具体的业务情况。这时候就可以愉快地做交集并集了。&#xA;13.之前研究了网页编码，一开始都是采用了resp.text，后来发现其实requests底层使用的是resp.encoding, 这个encoding的默认值取的是response.headers里的content-type中charset这个值，如果没有这个值呢，requests就会使用chardet进行编码判断(也就是get_encoding_from_headers)后来发现这个方法呢，其实并不好用，取出来的是个ISO-8859-1，这个东西解码字节数组以后也不对。又发现有一个get_encodings_from_content,这个是从html里面的meta里面取charset这个值。有些html会有多个meta标签，所以这个函数会取出多个charset，也就是一个列表。这个就要自己取取舍了。一般我认为如果是ISO-8859-1的话，就是用UTF进行编码，如果gb打头，就是用gb18030进行编码。因为gb2312&amp;lt;\gbk&amp;lt;\gb18030。另外很多时候，会出现一种情况就是，明明charset是对的，但是使用decode(charset)的时候会报错。这是因为网页中含有一些这个编码不可以解析的字符，是什么原因我不知道，但是可以使用decode(charset, &#39;ignore&#39;)，只显示那些能编码的字符。&#xA;14.虽然之前也遇到过supervisor装好了以后出现各种问题，今天尤其仔细地看了一下解决的方法，记录一下&#xA;supervisord -c /etc/supervisor/supervisord.conf 报错：Unlinking stale socket /var/run/supervisor.sock find / -name supervisor.sock # 全盘搜索这个文件名 unlink /**/supervisor.sock supervisord -c /etc/supervisor/supervisord.conf # 再重启supervisord服务 15.Python设计和历史常见问题&#xA;16.一个可以拿到访问者ip的接口&#xA;17.what-cicd&#xA;18.一些好用的网站？&#xA;在线ps&#xA;周读&#xA;临时邮箱&#xA;工具网</description>
    </item>
    <item>
      <title>docker image的实现原理以及registry相关的一块知识</title>
      <link>https://lydiacai1203.github.io/post/analyse_image_layer/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/analyse_image_layer/</guid>
      <description>part_one: 什么是文件挂载？ 1. Unix里面的文件目录是目录树结构的形式，所有的文件目录都是基于硬盘disk逻辑抽象出来的。比如现在有一个的一个目录。&#xA;接1. 现在要把这些文件目录挂载到磁盘上面，在linux的文件系统里面，首先执行mount命令进行文件挂载，比如说将/(根目录)挂载到disk1里面，挂载完了以后，根目录下的进行创建操作或是写操作的时候，数据文件都会存储在disk1当中。&#xA;重点来了。比如说现在在data目录下创建一个文件a.txt, 这时候将/data挂载到disk2下面，这时候disk2中是看不到a.txt的。&#xA;part_two: 联合挂载 那么既然有要挂载以后再写才能看见的挂载，肯定有写完以后再挂载依旧能够看见之前已经写了的文件的挂载方式。docker layer就是属于这种。&#xA;part_three: docker 的layer和image的关系就有点像联合目录以及挂载点 也就是说，一个image代表的就是layer中的一个挂载点，而所有的layers就像是一个联合目录。&#xA;最先进行build的layer层就在栈底，同样最后build的layer层就在栈顶。比如说现在在layer1层进行touch a.txt和touch b.txt两个动作(要注意现在图中所示的所有layer层都是read-only)。layer2层进行touch a.txt。那么这个时候整个docker image build以后，使用这个image生成的实例以后，这个实例里面存在的是哪一层的a.txt。&#xA;这就涉及到所谓的联合挂载了。也就是说当前的docker image 看得到之前的 docker image创建的全部的layers。现在请注意，接下来是重中之重，涉及image实现原理。课代表请记笔记。(我真的是个戏精)&#xA;part_three: docker image 实际上是怎么实现的 上个部分说到docker image是由很多个layer组成的，且这些layer是read-only的。每当生成一个新的实例以后，就会在栈顶增加一个writable-layer层。实际上是复制了一份read-only-layer中的数据到writable-layer中, 在container中修改的是这一层writable-layer中的数据。&#xA;好了，现在已经扯远了，回到问题上来，实际上一个docker image是由两部分组成的，分别是Manifest(layer_name list)和image_name(image_name: name:tag)&#xA;layer list中的每一个item，都是一个由hash(layer_content)=sha-256的这样一个hash值组成的。这样的hash有三个优点：1. 分布均匀；2. 碰撞少；3. 容易出现雪崩效应(所谓的雪崩效应输入值稍微改动一点点，hash值就会产生巨大的变化，这也是导致分布均匀的原因之一)。ps:Manifest也可以理解为是文件清单的意思。register(docker中的仓库)中其实存放了很多很多很多很多无序的layers。&#xA;part_four: 如何实现的layer不重复下载？ 当我们build Dockerfile的时候, 首先会根据Dockerfile生成一张Manifest的表。里面存的是一堆的hash值。会根据这张表从栈顶开始查，查到栈底，这个hash值实际上可以理解为是digest, 通过和本地layer的sha-256值进行比对判断有没有必要再创建一个。&#xA;part_five: 回到一开始的问题，生成的contianer里面到底是那个layer的里的a.txt 再回到文件系统来说，启动一个容器的时候，可以看到容器里面是有一个完整的文件系统的，容器里面的所有文件都来自构成镜像的层。每个层里面都有文件。Docker通过aufs的技术，把所有的层都挂载到了同一个目录上(所以现在知道，所谓digest其实就是，把所有layer里面的文件打包压缩求hash)。 也就是这时候container会从栈顶往下开始找文件，走到layer2的时候找到了a.txt, 这时候就不会用到layer3中的a.txt, 而是加载b.txt。所以说container里面的其实是a,txt文件。</description>
    </item>
    <item>
      <title>what is k8s?</title>
      <link>https://lydiacai1203.github.io/post/what_is_k8s/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/what_is_k8s/</guid>
      <description>part_one: 基本结构介绍 Node可以理解为物理资源，在K8s里面可操作的最小单元就是Pod，我们可以通过配置Pod配置文件的template字段来控制一个Pod里面有哪几种Container，但是不能控制一个Pod里面有几种container。Pod配置里面的template说明了要启动的容器是怎么样的，最重要的就是image的信息。&#xA;后来由于需要部署的服务越来越多，每个Pod都是人工手动启动或者是删除检查的。所以后来产生了ReplicaController，有了这个东西以后就可以指定每个服务所要启动的Pods。这里的selector就是现在RC管理的下，还有哪些Pod是存活的。然后template就是指的是要启动的Pod是什么样子的。&#xA;但是后来又遇到了滚动升级的问题(滚动升级：比如现在一个服务要从v1升级到v2，当时人工的处理方法就是将v1的Replica:3-&amp;gt;Replica:2, 然后将v2的配置文件里面配上Replica:1，后续的动作依次类推)。这样也耗费了大量的人力。&#xA;所以这时候Deployment就出现了，但是由于ReplicaController还有一些涉及的不好的地方，所以为了更好地与Deployment进行配合，于是就出现了ReplicaSet。&#xA;所以Deployment就是控制ReplicaSet的，Deployment里面可以看见RS和Pod两个东西的内容。&#xA;Pod在K8s里面，这是一个不稳定的东西，每次死掉以后再挂起来，Pod的IP都会发生变化。那怎么去准确地找到哪一个Pod呢？(这个和endpoint也有一点关系)但是一个服务起了多个Pod，这时候如果有流量过来应该分配给哪个Pod呢？于是就出现了Service，这个Service起到了一个所谓的负载均衡的作用。每一个Service在这个集群里都有唯一确定的IP，这样就可以找到一群Pods，然后每个Pod都由endpoint进行标识。&#xA;但是Service还是在这个虚拟网络里面的，外面用户来的流量应该怎么对应到指定的Service上面呢。之前说到外网想要连到百度云的服务器所在的私网的时候，使用的是VPN。但是我们不可能让用户都装上一个VPN Client。都进行验证。都建立一个虚拟专用网络。所以就出现了IngressController。这个东西可以简单地理解为是Nginx，可以实现反向代理。&#xA;外部的流量会直接访问域名通过ip查询会命中Nginx中配置当中的public ip，这时候会把流量导向Service。但是这个对应的实现就是，Ingress实际上就是一种映射机制，定义了映射规则。在IngressController里面存在这一份vhost,这个里面存在service_ip和port的映射。这样就可以实现外部网络访问内部对应的pod了。</description>
    </item>
    <item>
      <title>what is NFS?</title>
      <link>https://lydiacai1203.github.io/post/whatis_nfs/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/whatis_nfs/</guid>
      <description>part_one：一台物理机器上的文件存储 计算机里面有很多块磁盘，计算机里面的文件系统都是逻辑树状结构的，逻辑上的概念都是物理中不会出现的。一个一百兆的文件在计算机上有几种存储方法。简单地来说有两种:&#xA;1. sequence 在disk中占有一段连续的存储空间。这样做的好处有几点：一是简单方便；二是命中率高，因为程序的局部性原理。命中率高会导致读的速度比较快。但是这样做也是有坏处的，坏处就是这样存储文件容易出现磁盘碎片。因为不太容易找到100M这么大的连续存储空间。&#xA;2. Inode=index+data_node 这种方式会讲一个disk分成两个部分，一个部分是index表头，一个部分是很多很多的data node，这些data node的大小一都是可以设置的，一般的大小在4KB-&amp;gt;16KB。一个100M的文件会被分成好几个部分，被存储到不同的node里面去。然后在index表头里面做一个地址的记录。这样当把这个disk挂载到某个目录上面去的时候，文件系统要显示这个disk中的所有的文件，去找的时候就会根据这个index的表头去拼出一个完整的文件。&#xA;part_two：什么是NFS？ NFS的Network FileSystem，中文意思是分布式网络文件系统。这个出现的原因是因为，当目录下的文件非常多的时候，有可能会出现一个物理机里的磁盘存不下的情况。所以这种时候就出现了NFS。&#xA;拿一个例子来讲，所有远程registry里面的images的layers都是乱序的，且不可能只是存在于一台物理机上面。&#xA;1. 首先layers很多很多，不够存。&#xA;2. 其次就是必须看见的是一个文件系统，因为layer是被image各种交叉引用的。现在有一个NFS,做了一层隔离，一个文件可能分成几块存在不同的物理机的disk上面，然后这个NFS在显示文件目录下面的挂载情况的时候会将所有的物理机磁盘里的文件拼在一起展示在挂载的文件目录里面。造成一种假象。&#xA;3. NFS只是一种协议规范，真正实现这种规范的有GFS, GlusterFS, MooseFS等等，其中MooseFS就是所说的MFS，也就是公司现在用的这种分布式网络文件系统。&#xA;part_three: 磁盘阵列的好处 磁盘阵列会在你将数据写入一个磁盘的时候，同时同步到另一个磁盘上去。这样读写文件的速度就会变成两倍速。一个磁盘上从头开始读。另一个磁盘上从百分之五十的地方开始读数据。那可不可以说设置两个指针，一个在文件头，一个在文件尾进行读写呢，这样做会收到磁盘吞吐量的约束，所以也是一种有问题的做法。</description>
    </item>
    <item>
      <title>看完 天龙八部 以后，有一点骚话想说</title>
      <link>https://lydiacai1203.github.io/post/movie_tlbb/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      <guid>https://lydiacai1203.github.io/post/movie_tlbb/</guid>
      <description>我大概是疯了，从周日开始看到周一凌晨，终于把《天龙八部》给刷完了。&#xA;虚竹的故事线一条下来，我也觉得尚能接受。分支故事线应该就是天山童姥和李秋水，为了无崖子，一个划花对方的脸，一个在对方修炼神功的时候搞偷袭，还都觉得无崖子喜欢自己，结果无崖子喜欢的是李家小妹。虚竹也是个挂比，也算积善缘得善果，珍珑棋局为了救段延之误下一子，然后得段延之相助破解了珍珑棋局，得到了无崖子七十多年来的深厚内力，最后又因为一颗救人积善之心，结缘童姥，学会天山折梅手和天山六阳掌。也是因为阻止童姥和李秋水掐架最后误打误撞得到两人的内力，最后成为灵鹫宫主人。这样一个挂比小和尚，金庸也要给他安排上一段香艳场景，虽然梦姑梦郎终成眷属，但我总觉得冰窖中的那段描写像是一种意淫。虚竹的身世似乎也必须离奇，原来是玄慈与叶二娘的儿子，一天之内与父母相认，又一天之内失去双亲。&#xA;段誉也是一个名副其实的挂比+一个情商巨高的舔狗。先是因为救钟灵被灵鹫宫天使打落悬崖误打误撞习得凌波微步，接着又因为回头寻找小黑马主人而结识木婉清，去救木婉清的时候又把北冥神功给学会了，一不小心就吸了这个，吸了那个。跪舔王语嫣又别出心裁，不像宋青书那个蠢猪，当准备用六脉神剑下死招给慕容复的时候，还想到王姑娘会不会因此而不开心，可是宋青书这个蠢猪在张无忌身负重伤别人都不好意思上千补刀的时候，他还不自量力地想把张无忌干死。可谓是舔狗中的失败范例。同为舔狗的还有游坦之和阿紫，因为舔错了方式，而无法和自己心爱的人在一起。段誉还真的和段正淳一样，风流多情，原来三个爱人都是段正淳的女儿，正当我以为段誉要孤独一生的时候，故事又峰回路转，段誉竟然是段延之的儿子。我tm&amp;hellip;&#xA;自带音响的男人乔峰（萧峰）在喝断义酒的时候我真的心里难过极了，就不说了，大英雄谁都喜欢。虽然我看不太懂他为什么会爱上阿朱。&#xA;如果要我说我最喜欢谁，我应该最喜欢的是鸠摩智，典型的学霸，虽然有一丢丢急功近利，但是最后大彻大悟成为得道高僧也是相当有悟性有天赋的人，也是金庸没有给安排什么奇怪的感情线的人，所以我喜欢他。&#xA;就这样吧，我感觉金庸的其它作品我短期内应该都不会再去看了。</description>
    </item>
  </channel>
</rss>
